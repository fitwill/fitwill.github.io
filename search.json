[{"title":"集成学习","url":"/2020/06/11/集成学习/","content":"# 集成学习\n\n1. 集成学习`ensemble learning`是通过构建并结合多个学习器来完成学习任务。其一般结构为：\n\n   - 先产生一组“个体学习器”（`individual learner`) 。个体学习器通常由一种或者多种现有的学习算法从训练数据中产生。\n\n     - 如果个体学习器都是从某一种学习算法从训练数据中产生，则称这样的集成学习是同质的`homogenerous`。\n\n       此时的个体学习器也称作基学习器`base learner`，相应的学习算法称作基学习算法。\n\n     - 如果个体学习器是从某几种学习算法从训练数据中产生，则称这样的集成学习是异质的`heterogenous` 。\n\n   - 再使用某种策略将它们结合起来。集成学习通过将多个学习器进行组合，通常可以获得比单一学习器显著优越的泛化性能。\n\n2. 通常选取个体学习器的准则是：\n\n   - 个体学习器要有一定的准确性，预测能力不能太差。\n   - 个体学习器之间要有多样性，即学习器之间要有差异。\n\n3. 通常基于实际考虑，往往使用预测能力较强的个体学习器（即强学习器，与之对应的为弱学习器）。\n\n   强学习器的一个显著的好处就是可以使用较少数量的个体学习器来集成就可以获得很好的效果。\n\n4. 根据个体学习器的生成方式，目前的集成学习方法大概可以分作两类：\n\n   - 个体学习器之间存在强依赖关系、必须串行生成的序列化方法，每一轮迭代产生一个个体学习器。其中以`Boosting`为代表。\n   - 个体学习器之间不存在强依赖关系、可同时生成的并行化方法。其中以`Bagging`和随机森林`Random Forest`为代表。\n\n\n\n"},{"title":"【机器学习基础】 Lasso & Ridge regression, 正则化","url":"/2020/05/05/【机器学习基础】Lasso & Ridge regression/","content":"\n\nSlides的内容来自HKUST的Prof. Nevin L. ZHANG.\n\n<img src=\"【机器学习基础】Lasso & Ridge regression/1.png\" style=\"zoom:50%;\" />\n\n<img src=\"【机器学习基础】Lasso & Ridge regression/3.png\" style=\"zoom:50%;\" />\n\n<img src=\"【机器学习基础】Lasso & Ridge regression/2.png\" style=\"zoom:50%;\" />\n\n\n\n## Note\n\n- 这两个都是正则化的手段。LASSO是基于回归系数的一范数，Ridge是基于回归系数的二范数的平方;\n\n- 根据Hastie, Tibshirani, Friedman的经典教材，如果模型中有很多变量对模型都有些许影响，那么用Ridge；如果你的模型中只有少量变量对模型很大影响，那么用LASSO。LASSO可以使得很多变量的系数为0（相当于降维），特征选择，可以简化模型；而Ridge不会进行特征选择;\n- 因为Ridge计算起来更快，所以当数据量特别大的时候，更倾向于用Ridge;\n- 最万能的方法是用LASSO和Ridge都试一试，比较两者Cross Validation的结果;\n- 最后补充一下，你也可以尝试一下两者的混合，Elastic Net。","categories":["机器学习基础"]},{"title":"Linux常用指令速查","url":"/2020/05/03/linux指令/","content":"\n### awk\n\n```bash\nawk '{print $0}' file    #打印所有列\nawk '{print $1}' file  #打印第一列\nawk '{print $1, $3}' file   #打印第一和第三列\ncat file | awk '{print $3, $1}'   #打印第三列和第一列，注意先后顺序。\ncat file | awk '{print $3, $NF}' #打印第三列和最后一列\nawk -F \":\" '{print $1, $3}'  #以“:”为分隔符分割列，然后打印第一列和第三列\nawk '{for(i=13;i<=NF;i++) printf $i\" \";printf \"\\n\"}' file #打印第13列之后的所有\n```\n\n\n\n### paste\n\npaste会把每个文件以列对列的方式，一列列地加以合并。\n\n```bash\n文件： pas1\nID897\nID666\nID982\n文件： pg pas2\nP.Jones\nS.Round\nL.Clip\n\n1. 基本paste命令将pas1和pas2两文件粘贴成两列：\n    > paste pas1 pas2\n    ID897   P.Jones\n    ID666   S.Round\n    ID982   L.Clip\n2. 通过交换文件名即可指定哪一列先粘：\n    > paste pas2 pas1\n    P.Jones ID897\n    S.Round ID666\n    L.Clip ID982\n3. 要创建不同于空格或tab键的域分隔符，使用-d选项。下面的例子用冒号做域分隔符。\n    > paste -d: pas2 pas1\n    P.Jones:ID897\n    S.Round:ID666\n    L.Clip:ID982\n4. 要合并两行，而不是按行粘贴，可以使用-s选项。下面的例子中，第一行粘贴为ID号，第二行是名字。\n    > paste -s pas1 pas2\n    ID897   ID666   ID982\n    P.Jones S.Round L.Clip\n```","tags":["Linux"],"categories":["Linux"]},{"title":"【机器学习基础】XGBoost","url":"/2020/04/12/【机器学习基础】XGBoost/","content":"\n自从陈天奇于2015年提出XGBoost以来，该模型就一直在各大数据竞赛中当作大杀器被频繁祭出。速度快、效果好是XGBoost的最大优点。XGBoost与GBDT同出一脉，都属于boosting集成学习算法，但XGBoost相较于GBDT要青出于蓝而胜于蓝。\n\n XGBoost的全称为eXtreme Gradient Boosting，即极端梯度提升树。要深入理解整个XGBoost模型系统，建议还是要认真研读陈天奇的 **XGBoost: A Scalable Tree Boosting System** 论文，深入损失函数的推导，这样才能更好的掌握XGBoost。本文仅对模型最重要的部分，即XGBoost损失函数的数学推导过程和结点分裂的增益计算方式进行阐述。\n\n###XGBoost原理推导\n\n既然XGBoost整体上仍然属于GBDT系统，那么XGBoost也一定是由多个基模型组成的一个加法模型，所以XGBoost可表示为：\n\n","categories":["机器学习基础"]},{"title":"【机器学习基础】GBDT","url":"/2020/03/24/【机器学习基础】GBDT/","content":"\n### 概述\n\nGBDT全称为Gradient Boosting Decison Tree，是boosting家族的一员，其弱学习器限定只能用CART回归树模型。在GBDT的迭代中，假设我们前一轮迭代得到的强学习器是$f_{𝑡−1}(𝑥)$, 损失函数是$𝐿(𝑦,𝑓_{𝑡−1}(𝑥))$，我们本轮迭代的目标是找到一个CART回归树模型的弱学习器$ℎ_𝑡(𝑥)$，最小化本轮的损失函数$$ L(y,f_t(x)=L(y, f_{t−1}(x)+h_t(x))$$也就是说，本轮迭代找到决策树，要让样本的损失尽量变得更小。\n\nGBDT的思想可以用一个通俗的例子解释，假如有个人30岁，我们首先用20岁去拟合，发现损失有10岁，这时我们用6岁去拟合剩下的损失，发现差距还有4岁，第三轮我们用3岁拟合剩下的差距，差距就只有一岁了。如果我们的迭代轮数还没有完，可以继续迭代下面，每一轮迭代，拟合的岁数误差都会减小。最终把每棵树的结论加起来，本例中即为 20+6+3+1 = 30。实际工程中，GBDT是计算负梯度，用负梯度近似残差。\n\n### GBDT的负梯度拟合\n\nFreidman提出了用损失函数的负梯度来拟合本轮损失的近似值，进而拟合一个CART回归树。第$t$轮的第$i$个样本的损失函数的负梯度表示为\n\n","categories":["机器学习基础"]},{"title":"【机器学习基础】决策树","url":"/2020/03/17/【机器学习基础】决策树/","content":"\n\n\n### 基本概念\n\n1. 决策树是极其接近人类思维的一种机器学习算法，没有包含很复杂的数学模型。其本质是从训练数据集中归纳出一条分类规则；\n\n2. 决策树的判别过程可以视作 IF-THEN 模型，即：根据样本某个特征的取值，不断地判别下去，对数据集做划分，直至归类成功；IF-THEN 是互斥且完备的，即：每一个样本点都被一条且仅被一条决策的路径所覆盖；\n3. 决策树是树型结构，其根节点为全部样本点的集合，中间结点表示某一个特征或者属性，叶子结点表示某一个类；\n\n4. 决策树学习通常包括三个步骤：特征选择、决策树生成以及决策树的剪枝。\n\n\n\n### 特征选择\n\n既然决策树只是在不停地做 IF-THEN，那么问题就出现了：一个样本有n个属性的话，如何选择属性的优先性呢？\n\n**我们通常根据信息增益或者信息增益比来做特征选择，选择数值更大的属性作为划分依据。**\n\n那么什么是信息增益/信息增益比？这里，我们来了解以下概念。\n\n#### Concept_1 信息熵\n\n1. 直观理解：熵描述了（系统/随机变量的）不确定性。熵越大，不确定性越大，信息含量越少。\n2. 公式： $$H(X)=-\\sum_{i=1}^{n}p_{i}log_{2}p_{i}$$\n\n3. 熵仅依赖X的分布，与X的取值无关，因此又可以记作：$H(p)=-\\sum_{i=1}^{n}p_{i}log_{2}p_{i}$\n\n#### Concept_2 条件熵\n\n1. $H(Y|X)$ 定义为：在X给定条件下，Y的条件概率分布的熵 对X的数学期望；\n\n2. 公式：$$H(Y|X)=\\sum_{i=1}^{n}p_{i}H(Y|X=x_{i})$$\n\n信息熵里的 $p_{i}$ 的计算是根据 当前样本集的分类情况，依据概率分布来计算。\n而条件熵里的 $p_{i}$ 的计算是根据 当前样本集按照某个属性划分后，每一个划分占总体的比例来计算\n举栗请看《统计学习方法》P62 例5.2 \n\n#### Concept_3 信息增益\n\n特征A对数据集D的信息增益$g(D, A)$定义为：集合D的熵$H(D)$与特征A给定条件下D的经验熵$H(D|A)$之差，\n\n即：$$g(D, A)=H(D)-H(D|A)$$\n\n信息增益的符号，在有些地方也用gain()表示。\n\n#### Concept_4 信息增益比\n\n特征A对数据集D的信息增益比$g_{R}\\left ( D, A\\right )$定义为：\n\n信息增益$g(D, A)$与训练集D关于特征A的值的熵$H_{A}(D)$的比值. 即：$$g_{R}\\left ( D, A\\right )= \\frac{g\\left ( D, A \\right )}{H_{A}(D)}$$\n\n其中，$$H_{A}(D)=-\\sum_{i=1}^{n}\\frac{D_{i}}{D}log_{2}\\frac{D_{i}}{D}$$\n\n$D_{i}$ 是根据属性A划分出的第i个子集.\n\n\n\n### 决策树生成\n\n本节包含ID3、C4.5和CART算法，CART放在[CART决策树](#cartdt)部分学习。\n\n#### ID3算法\n\nID3算法就是在决策树的各个节点上应用信息增益来选择特征，递归的构建决策树。\n\n具体来讲：\n\n1. 从根节点开始，对节点计算所有可能的特征的信息增益；\n\n2. 选择增益最大的特征作为节点的特征，以该特征的不同取值进行划分，建立子节点；\n\n3. 递归下去，直到信息增益很小（人为地设置一个阈值）或者无特征为止。\n\n缺点：ID3会对 包含类别较多 的特征有选择的偏向性，因此提出c4.5算法。\n\n#### C4.5算法\n\n与ID3的区别：\n\n1. 在特征选择时，先从候选属性中选择信息增益高于平均水平的属性，再从中选择信息增益率最高的属性；\n\n2. 此处的阈值是信息增益比的最小值。\n\n\n\n### 剪枝策略\n\n#### 为何剪枝：\n\n决策树生成算法根据训练集递归的生成了决策树，但是这样产生的树往往对训练数据集的分类很准确，却对测试数据集却没那么准确，即发生了过拟合现象。因此我们需要把复杂的树简单化。\n\n#### 预剪枝\n\n在选定了划分属性后，我们提出问题：是否应该进行这个划分？这就是预剪枝。\n\n预剪枝就是在完全正确分类训练集之前，较早地停止树的生长。\n\n具体在什么时候停止决策树的生长有多种不同的方法:\n\n1. 最为简单的方法：在决策树到达一定高度的情况下就停止树的生长；\n2. 定义一个阈值，当达到某个节点的实例个数小于阈值时就可以停止决策树的生长;\n3. 一种更为普遍的做法是计算划分前后系统精度的变化。如果更加精确，则允许划分，否则不允许（西瓜书4.31.节即采用本策略）。\n\n优点降低了过拟合，减少训练时间，***缺点容易带来欠拟合***。\n\n#### 后剪枝\n\n后剪枝技术要比预剪枝技术用得更加广泛。此处着重介绍。\n\n**方法1 - Reduced Error Pruning（西瓜书）**\n\n对于决策树T的每棵非叶子树S , 以“深度优先”的顺序，尝试用叶子替代这棵子树. 如果 S 被叶子替代后形成的新树关于数据集D的分类准确率等于或大于原树关于相同数据集D的准确率, 则用叶子替代子树S。\n\n**方法2 - 极小化决策树整体的损失函数（统计学习方法）**\n\n损失函数：\n\n$$C_α(T) = C(T)+α|T|=\\sum_{t=1}^{|T|}N_tH_t(T)+α|T|$$\n\n$$H_t(T)=−\\sum_{k}\\frac{N_{tk}}{N_t}log\\frac{N_{tk}}{N_t}$$ \n\n其中，$|T|$是树$T$的叶节点个数，$t$是其中一个结点，$N_t$是这个结点的样本个数，$H_t(T)$是这个结点的经验熵（就是普通的熵）。$C(T)$表示模型对训练数据的预测误差，即模型与训练数据的拟合程度， $|T|$是模型的复杂程度，$\\alpha$用来控制两者之间的关系。使用叶子结点的熵作为的模型的评价是因为：如果分到该叶节点的所有样本都属于同一类，不确定数量 = 不确定度 * 样本数量，那么分类效果最好，熵最小。\n\n在这里我存在疑问：\n\n叶结点上为什么存在k类样本点？即在该叶结点上，所有类别标签应该都是一致的。\n\n可能解释：\n\n1. 在该叶结点上没有足够的特征信息再把不一致的标签分开；\n2. 存在噪声点，何谓噪声，在类群中有极少个与类群不符的标签。\n\n\n\n###  <span id=\"cartdt\">CART决策树</span>\n\nCART决策树全称为classification and regression tree，CART假设决策树是二叉树，内部结点特征的取值为是和否，等价于递归地二分每个特征。\n\n#### CART 回归树\n\n见[CART回归树原理及示例](https://blog.csdn.net/aaa_aaa1sdf/article/details/81588382)。\n\n#### CART分类树\n\n分类树用Gini index选择最优的特征，同时决定该特征下的最优二分点。\n\n#### Concept_5 Gini index\n\n假设有K个类，样本点属于第k类的概率为$p_k$，则概率分布的Gini index定义为：\n\n$$Gini(p) = \\sum_{k=1}^{K}p_k(1-p_k)=1-\\sum_{k=1}^{K}p_k^2$$\n\n对于二分类问题，假设样本点是第一类的概率为$p$，则概率分布的Gini index为：\n\n$$Gini(p) = 2p(1-p)$$\n\n对于给定的样本集合D，把概率写作数量的比值，其Gini index为：\n\n$$Gini(D) = 1-\\sum_{k=1}^{K}(\\frac{|C_k|}{|D|})^2$$\n\n如果样本集合D根据特征A是否取某一可能的值a被分割成了$D_1$和$D_2$两个部分，则在特征A的条件下，集合D的基尼指数定义为：\n\n$$Gini(D, A)=\\frac{|D_1|}{|D|}Gini(D_1) + \\frac{|D_2|}{|D|}Gini(D_2)$$\n\n$Gini(D)$代表集合$D$的不确定性，$Gini(D, A)$表示经$A=a$分割后集合$D$的不确定性。Gini index越大，样本的不确定性就越大。\n\n#### CART分类树的生成\n\n伪代码总结为：\n\n```python\nfor  A in feature space:\n\tfor a in A.values:\n\t\tcalculateGini(A = a)\nchoose the lowest Gini index\n```\n\n《统计学习方法》相关描述为：\n\n<img src=\"【机器学习基础】决策树/image-20200318104650131.png\" alt=\"image-20200318104650131\" style=\"zoom: 50%;\" />\n\n<img src=\"【机器学习基础】决策树/image-20200318105140830.png\" alt=\"image-20200318105013644\" style=\"zoom:50%;\" />\n\n#### CART剪枝\n\n基本思路：CART剪枝算法从“完全生长”的决策树的底端剪去一些子树，使决策树变小（模型变简单），从而能够对未知数据有更准确的预测。CART剪枝算法由两步组成：1. 首先从生成算法产生的决策树$T_0$底端开始不断剪枝，直到$T_0$的根结点，形成一个子树序列{$T_0$,$T_1$,...,$T_n$}；2. 然后通过交叉验证法在独立的验证数据集上对子树序列进行测试，从中选择最优子树。\n\n接下来截取统计学习方法的内容。\n\n<img src=\"【机器学习基础】决策树/image-20200318111527018.png\" alt=\"image-20200318111527018\" style=\"zoom:50%;\" />\n\n<img src=\"【机器学习基础】决策树/image-20200318111742773.png\" alt=\"image-20200318111742773\" style=\"zoom:50%;\" />\n\n<img src=\"【机器学习基础】决策树/image-20200318113410309.png\" alt=\"image-20200318113410309\" style=\"zoom:50%;\" />\n\n#### CART剪枝的原理思考\n\nloss function的定义为：\n\n$$C_α(T) = C(T)+α|T|=\\sum_{t=1}^{|T|}N_tH_t(T)+α|T|$$\n\n对其进行变形：\n\n$$C_α(T) =\\sum_{t=1}^{|T|}(N_tH_t(T)+α)$$\n\n由此看出，衡量损失函数大小的真正贡献在于每一棵子树的叶结点，叶结点不确定次数的累加并加个常数$\\alpha $就是决策树整体的损失函数。\n\n","categories":["机器学习基础"]},{"title":"【NLP】对话生成任务中的数据清理","url":"/2020/02/17/【NLP】对话生成任务中的数据清理/","content":"\n在本次对话生成的任务中，需要对微博数据进行清理，去除其中不应feed到网络中的字符。主要包括以下：\n\n\n\n1. 颜文字；\n2. emoji；\n3. 相同且重复多次的正常标点只保留一个；\n4. 不同且重复多次的异常标点删掉；\n5. 话题标识删掉；\n6. @/via/http:后缀/cite删掉；\n\n\n\n下面是代码部分。在处理时因为赶时间，直接采用了暴力破解，只是在执行的先后顺序上做了一些调整，这里***MARK***，以后有时间做一下改进。\n\n```python\nimport jieba\nimport re\n\nduels = [x + y for x in list('。，!？！？:.（）()【】,《》\\'\\\"、,') \n                for y in list('。，!？！？:.（）()【】,《》\\'\\\"、,')]\ndef handle_symbol(text, duels):\n    '''\n        1. 删除重复的标点符号，只保留一个；\n        2. 删除特殊符号；\n    '''\n    remove = list('ノ¯︶ーσ･з∠~〜*&%$-_+=＊ｰ ̀ ́；●ヾД≤≥ε┏゜ロ┛□▔﹏∇ψ❤三 ڡ ♂ㄒ;∂‸Ծˋ๑ºั`·ﾟ\\\n                ゝ[]○▽￥←┴・｀.「﹃『』」∩ヽ ﾟ∀ｏ`´╭╮【Σっ★╥¬☆＜⌒ﾉ】→↑°╰╯┴x•ㅂ…|\\/^<\\\n                >口︵—≧≦⊙ω∑√')\n    for r in remove:\n        while r in text:\n            text = text.replace(r,\"\")\n    for d in duels:\n        while d in text:\n            if d[0] == d[1]: text = text.replace(d,d[0])\n            else: text = text.replace(d,\"\")\n    while text[0] in list('。，!？！？:.（）()【】,《》\\'\\\"、,'):\n        text = text[1:]\n    return text\ndef rm_ref(text):\n    '''\n        删除@/via/\n    '''\n    text = text.split(\"分享自via:\")[0] if \"分享自via:\" in text else text\n    text = text.split(\"（图via\")[0] if \"（图via\" in text else text\n    text = text.split(\"图via\")[0] if \"图via\" in text else text\n    text = text.split(\"@\")[0] if \"@\" in text else text\n    text = text.split(\"(via\")[0] if \"(via\" in text else text\n    text = text.split(\"\")[0] if \"via\" in text else text\n    text = text.split(\"by:\")[0] if \"via\" in text else text\n    text = text.split(\"(by\")[0] if \"via\" in text else text\n    return text\n\ndef filter_emoji(desstr,restr=''):  \n    '''\n        过滤emoji\n    '''   \n    try:  \n        res= re.compile(u'[\\U00010000-\\U0010ffff]')  \n    except re.error:  \n        res = re.compile(u'[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]')  \n    return res.sub(restr, desstr)\n\ndef rm_cite(text):\n    '''\n        删除http:/##/\n    '''\n    text = text.replace(\"http:\", \"\")\n    text = re.sub(r'#.*#', '', text)\n    return text\n\ntarget = open(\"after_cleaned_test.txt\", \"w\")\nwith open(\"./tweets_cleaned.txt\", 'r') as f:\n    for line in f:\n        try:\n            line = line.strip().split(\"\\t\")\n            # 清洗\n            line[3] = rm_ref(line[3])\n            line[3] = filter_emoji(line[3])\n            line[3] = rm_cite(line[3])\n            line[3] = handle_symbol(line[3], duels)\n            line[7] = rm_ref(line[7])\n            line[7] = filter_emoji(line[7])\n            line[7] = rm_cite(line[7])\n            line[7] = handle_symbol(line[7], duels)\n            \n            # 分词\n            line[3] = \" \".join(jieba.cut(line[3], cut_all=False))\n            line[7] = \" \".join(jieba.cut(line[7], cut_all=False))\n            target.write(\"\\t\".join(line) + \"\\n\")\n        except:\n            continue\n\n```","tags":["EMNLP2020"],"categories":["NLP"]},{"title":"【NLP】统计学习的语言模型","url":"/2020/02/15/【NLP】统计学习的语言模型/","content":"\n\n\n# 语言模型\n\n一段自然语言文本可以看作是一个离散时间序列，给定一个长度为$T$的词的序列$w_1, w_2, \\ldots, w_T$。\n语言模型的目标就是评估该序列是否合理，即计算该序列的概率：\n\n$$\nP(w_1, w_2, \\ldots, w_T) \n$$\n\n\n本节我们介绍基于统计的语言模型，主要是$n$元语法（$n$-gram）。在后续内容中，我们将会介绍基于神经网络的语言模型。\n\n\n\n## 统计学习的语言模型\n\n\n假设序列$w_1, w_2, \\ldots, w_T$中的每个词是依次生成的，我们有\n\n\n$$\n\\begin{align*}\nP(w_1, w_2, \\ldots, w_T)\n&= \\prod_{t=1}^T P(w_t \\mid w_1, \\ldots, w_{t-1})\\\\\n&= P(w_1)P(w_2 \\mid w_1) \\cdots P(w_T \\mid w_1w_2\\cdots w_{T-1})\n\\end{align*}\n$$\n\n\n例如，一段含有4个词的文本序列的概率\n\n\n$$\nP(w_1, w_2, w_3, w_4) =  P(w_1) P(w_2 \\mid w_1) P(w_3 \\mid w_1, w_2) P(w_4 \\mid w_1, w_2, w_3).\n$$\n\n\n语言模型的参数就是词的概率以及给定前几个词情况下的条件概率。设训练数据集为一个大型文本语料库，如维基百科的所有条目，词的概率可以通过该词在训练数据集中的相对词频来计算，例如，$w_1$的概率可以计算为：\n\n\n$$\n\\hat P(w_1) = \\frac{n(w_1)}{n}\n$$\n\n\n其中$n(w_1)$为语料库中以$w_1$作为第一个词的文本的数量，$n$为语料库中文本的总数量。\n\n类似的，给定$w_1$情况下，$w_2$的条件概率可以计算为：\n\n\n$$\n\\hat P(w_2 \\mid w_1) = \\frac{n(w_1, w_2)}{n(w_1)}\n$$\n\n其中$n(w_1, w_2)$为语料库中以$w_1$作为第一个词，$w_2$作为第二个词的文本的数量。\n\n***注意，这里的n指的不是w1,w1w2单词出现的次数，而是以w1, w1w2开头的文本数量。***\n\n\n\n## n元语法\n\n序列长度增加，计算和存储多个词共同出现的概率的复杂度会呈指数级增加。$n$元语法通过马尔可夫假设简化模型，马尔科夫假设是指一个词的出现只与前面$n$个词相关，即$n$阶马尔可夫链（Markov chain of order $n$），如果$n=1$，那么有$P(w_3 \\mid w_1, w_2) = P(w_3 \\mid w_2)$。基于$n-1$阶马尔可夫链，我们可以将语言模型改写为\n\n\n$$\nP(w_1, w_2, \\ldots, w_T) = \\prod_{t=1}^T P(w_t \\mid w_{t-(n-1)}, \\ldots, w_{t-1}) .\n$$\n\n\n以上也叫$n$元语法（$n$-grams），它是基于$n - 1$阶马尔可夫链的概率语言模型。例如，当$n=2$时，含有4个词的文本序列的概率就可以改写为：\n\n\n$$\n\\begin{align*}\nP(w_1, w_2, w_3, w_4)\n&= P(w_1) P(w_2 \\mid w_1) P(w_3 \\mid w_1, w_2) P(w_4 \\mid w_1, w_2, w_3)\\\\\n&= P(w_1) P(w_2 \\mid w_1) P(w_3 \\mid w_2) P(w_4 \\mid w_3)\n\\end{align*}\n$$\n\n\n当$n$分别为1、2和3时，我们将其分别称作一元语法（unigram）、二元语法（bigram）和三元语法（trigram）。例如，长度为4的序列$w_1, w_2, w_3, w_4$在一元语法、二元语法和三元语法中的概率分别为\n\n\n$$\n\\begin{aligned}\nP(w_1, w_2, w_3, w_4) &=  P(w_1) P(w_2) P(w_3) P(w_4) ,\\\\\nP(w_1, w_2, w_3, w_4) &=  P(w_1) P(w_2 \\mid w_1) P(w_3 \\mid w_2) P(w_4 \\mid w_3) ,\\\\\nP(w_1, w_2, w_3, w_4) &=  P(w_1) P(w_2 \\mid w_1) P(w_3 \\mid w_1, w_2) P(w_4 \\mid w_2, w_3) .\n\\end{aligned}\n$$\n\n当$n$较小时，$n$元语法往往并不准确。例如，在一元语法中，由三个词组成的句子“你走先”和“你先走”的概率是一样的。然而，当$n$较大时，$n$元语法需要计算并存储大量的词频和多词相邻频率。\n\n\n\n***思考：$n$元语法可能有哪些缺陷?***\n\n1. 参数空间过大；\n2. 数据稀疏。\n\n\n\n## 语言模型数据集\n### 读取数据集\n\n```python\nwith open('jaychou_lyrics.txt') as f:\n    corpus_chars = f.read()\nprint(len(corpus_chars))\nprint(corpus_chars[: 40])\ncorpus_chars = corpus_chars.replace('\\n', ' ').replace('\\r', ' ')\ncorpus_chars = corpus_chars[: 10000] # 只保留前10000个字符\n\n# output\n# 63282\n# 想要有直升机\n# 想要和你飞到宇宙去\n# 想要和你融化在一起\n# 融化在宇宙里\n# 我每天每天每\n```\n\n### 建立字符索引\n\n```python\nidx_to_char = list(set(corpus_chars)) # 去重，得到索引到字符的映射\nchar_to_idx = {char: i for i, char in enumerate(idx_to_char)} # 字典推导式，构造字符到索引的映射\nvocab_size = len(char_to_idx)\nprint(vocab_size)\n\ncorpus_indices = [char_to_idx[char] for char in corpus_chars]  # 将每个字符转化为索引，得到一个索引的序列\nsample = corpus_indices[: 20]\nprint('chars:', ''.join([idx_to_char[idx] for idx in sample]))\nprint('indices:', sample)\n\n# output:\n# 1027\n# chars: 想要有直升机 想要和你飞到宇宙去 想要和\n# indices: [519, 525, 36, 664, 964, 16, 522, 519, 525, 184, 784, 828, 218, 371, 618, 889, 522, 519, 525, 184]\n\n# 定义函数`load_data_jay_lyrics`，在后续章节中直接调用。\ndef load_data_jay_lyrics():\n    with open('jaychou_lyrics.txt') as f:\n        corpus_chars = f.read()\n    corpus_chars = corpus_chars.replace('\\n', ' ').replace('\\r', ' ')\n    corpus_chars = corpus_chars[0:10000]\n    idx_to_char = list(set(corpus_chars))\n    char_to_idx = dict([(char, i) for i, char in enumerate(idx_to_char)])\n    vocab_size = len(char_to_idx)\n    corpus_indices = [char_to_idx[char] for char in corpus_chars]\n    return corpus_indices, char_to_idx, idx_to_char, vocab_size\n```\n\n\n\n## 时序数据的采样\n\n在训练中我们需要每次随机读取小批量样本和标签。与之前章节的实验数据不同的是，时序数据的一个样本通常包含连续的字符。假设时间步数为5，样本序列为5个字符，即“想”“要”“有”“直”“升”。该样本的标签序列为这些字符分别在训练集中的下一个字符，即“要”“有”“直”“升”“机”，即$X$=“想要有直升”，$Y$=“要有直升机”。\n\n现在我们考虑序列“想要有直升机，想要和你飞到宇宙去”，如果时间步数为5，有以下可能的样本和标签：\n\n- $X$：“想要有直升”，$Y$：“要有直升机”\n- $X$：“要有直升机”，$Y$：“有直升机，”\n- $X$：“有直升机，”，$Y$：“直升机，想”\n- ...\n- $X$：“要和你飞到”，$Y$：“和你飞到宇”\n- $X$：“和你飞到宇”，$Y$：“你飞到宇宙”\n- $X$：“你飞到宇宙”，$Y$：“飞到宇宙去”\n\n可以看到，如果序列的长度为$T$，时间步数为$n$，那么一共有$T-n$个合法的样本，**但是这些样本有大量的重合**，我们通常采用更加高效的采样方式。我们有两种方式对时序数据进行采样，分别是随机采样和相邻采样。\n\n### 随机采样\n\n下面的代码每次从数据里随机采样一个小批量。其中批量大小`batch_size`是每个小批量的样本数，`num_steps`是每个样本所包含的时间步数。\n在随机采样中，每个样本是原始序列上任意截取的一段序列，相邻的两个随机小批量在原始序列上的位置不一定相毗邻。\n\n![1](统计学习的语言模型/1.png)\n\n```python\nimport torch\nimport random\ndef data_iter_random(corpus_indices, batch_size, num_steps, device=None):\n    # 减1是因为对于长度为n的序列，X最多只有包含其中的前n - 1个字符\n    num_examples = (len(corpus_indices) - 1) // num_steps  # 下取整，得到不重叠情况下的样本个数\n    example_indices = [i * num_steps for i in range(num_examples)]  # 每个样本的第一个字符在corpus_indices中的下标\n    random.shuffle(example_indices)\n\n    def _data(i):\n        # 返回从i开始的长为num_steps的序列\n        return corpus_indices[i: i + num_steps]\n    if device is None:\n        device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n    \n    for i in range(0, num_examples, batch_size):\n        # 每次选出batch_size个随机样本\n        batch_indices = example_indices[i: i + batch_size]  # 当前batch的各个样本的首字符的下标\n        X = [_data(j) for j in batch_indices]\n        Y = [_data(j + 1) for j in batch_indices]\n        yield torch.tensor(X, device=device), torch.tensor(Y, device=device)\n```\n\n测试一下这个函数，我们输入从0到29的连续整数作为一个人工序列，设批量大小和时间步数分别为2和6，打印随机采样每次读取的小批量样本的输入`X`和标签`Y`。\n\n```python\nmy_seq = list(range(30))\nfor X, Y in data_iter_random(my_seq, batch_size=2, num_steps=5):\n    print('X: ', X, '\\nY:', Y, '\\n')\n   \n# output:\n# X: tensor([[20, 21, 22, 23, 24],\n#         [ 5,  6,  7,  8,  9]]) \n# Y: tensor([[21, 22, 23, 24, 25],\n#         [ 6,  7,  8,  9, 10]]) \n#\n# X:  tensor([[ 0,  1,  2,  3,  4],\n#         [10, 11, 12, 13, 14]]) \n# Y: tensor([[ 1,  2,  3,  4,  5],\n#         [11, 12, 13, 14, 15]]) \n#\n# X:  tensor([[15, 16, 17, 18, 19]]) \n# Y: tensor([[16, 17, 18, 19, 20]]) \n```\n\n\n\n### 相邻采样\n\n除对原始序列做随机采样之外，我们还可以令相邻的两个随机小批量在原始序列上的位置相毗邻。这时候，我们就可以用前一个小批量最终时间步的隐藏状态来初始化下一个小批量的隐藏状态，从而使下一个小批量的输出也取决于当前小批量的输入，并如此循环下去。这对实现循环神经网络造成了两方面影响：\n\n一方面，在训练模型时，我们只需在每一个迭代周期开始时初始化隐藏状态；\n\n另一方面，当多个相邻小批量通过传递隐藏状态串联起来时，模型参数的梯度计算将依赖所有串联起来的小批量序列。同一迭代周期中，随着迭代次数的增加，梯度的计算开销会越来越大。\n\n为了使模型参数的梯度计算只依赖一次迭代读取的小批量序列，我们可以在每次读取小批量前将隐藏状态从计算图中分离出来。我们将在下一节（循环神经网络的从零开始实现）的实现中了解这种处理方式。\n\n![2](统计学习的语言模型/2.png)\n\n```python\ndef data_iter_consecutive(corpus_indices, batch_size, num_steps, device=None):\n    if device is None:\n        device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n    corpus_len = len(corpus_indices) // batch_size * batch_size  # 保留下来的序列的长度\n    corpus_indices = corpus_indices[: corpus_len]  # 仅保留前corpus_len个字符，以保证可以整除batch_size\n    indices = torch.tensor(corpus_indices, device=device)\n    indices = indices.view(batch_size, -1)  # resize成(batch_size, )\n    batch_num = (indices.shape[1] - 1) // num_steps\n    for i in range(batch_num):\n        i = i * num_steps\n        X = indices[:, i: i + num_steps]\n        Y = indices[:, i + 1: i + num_steps + 1]\n        yield X, Y\n        \nfor X, Y in data_iter_consecutive(my_seq, batch_size=2, num_steps=6):\n    print('X: ', X, '\\nY:', Y, '\\n')\n    \n# output:\n# X:  tensor([[ 0,  1,  2,  3,  4,  5],\n#         [15, 16, 17, 18, 19, 20]]) \n# Y: tensor([[ 1,  2,  3,  4,  5,  6],\n#         [16, 17, 18, 19, 20, 21]]) \n#\n# X:  tensor([[ 6,  7,  8,  9, 10, 11],\n#         [21, 22, 23, 24, 25, 26]]) \n# Y: tensor([[ 7,  8,  9, 10, 11, 12],\n#         [22, 23, 24, 25, 26, 27]]) \n```\n\n","tags":["Dive系列"],"categories":["NLP"]},{"title":"【NLP】文本预处理","url":"/2020/02/15/【NLP】文本预处理/","content":"\n\n\n## 文本预处理\n\n文本是一类序列数据，一篇文章可以看作是字符或单词的序列，本节将介绍文本数据的常见预处理步骤，预处理通常包括四个步骤：1. 读入文本；2. 句子转化为词序列；3. 建立字典，将每个词映射到一个唯一的索引；4.将文本从词的序列转换为索引的序列，方便输入模型。\n\n\n\n### 读入文本\n\n我们用一部英文小说，即H. G. Well的[Time Machine](http://www.gutenberg.org/ebooks/35)，作为示例，展示文本预处理的具体过程。\n\n``` python\nimport collections\nimport re\n\ndef read_time_machine():\n    with open('timemachine.txt', 'r') as f:\n        # 此处正则表达式表示：1.去掉开头结尾的空格和制表符；2.大写字母转小写；\n        # 3.把所有的非a-z的字符转化为空格。\n        lines = [re.sub('[^a-z]+', ' ', line.strip().lower()) for line in f]\n    return lines\n    \nlines = read_time_machine()\nprint('Info: Num of sentences is %d.' % len(lines))\n\n# output: Info: Num of sentences is 3221.\n```\n\n\n\n### 句子转化为词序列 - 简单的分词\n\n将一个句子划分成若干个词（token），转换为一个词的序列。\n``` python\ndef tokenize(sentences, token):\n    \"\"\"Split sentences into word or char tokens\"\"\"\n    if token == 'word':\n        return [sentence.split(' ') for sentence in sentences]\n    elif token == 'char':\n        return [list(sentence) for sentence in sentences]\n    else:\n        print('ERROR: unkown token type '+token)\n        \ntokens = tokenize(lines, 'word')\ntokens[0:2]\n\n# output: [['the', 'time', 'machine', 'by', 'h', 'g', 'wells', ''], ['']]\n```\n\n\n\n### 建立字典\n\n为了方便模型处理，我们需要将字符串转换为数字。因此我们需要先构建一个字典（vocabulary），将每个词映射到一个唯一的索引编号。\n\n```python\nclass Vocab(object):\n    def __init__(self, tokens, min_freq=0, use_special_tokens=False):\n        # min_freq为阈值\n        counter = count_corpus(tokens)\n        self.token_freqs = list(counter.items())\n        self.idx_to_token = []\n        if use_special_tokens:\n            # padding, begin of sentence, end of sentence, unknown\n            # unk是指在语料库中未出现过的token\n            # 需要注意：无论use_special_token参数是否为真，都会使用UNK来表示未登录词。\n            self.pad, self.bos, self.eos, self.unk = (0, 1, 2, 3)\n            self.idx_to_token += ['', '', '', '']\n        else:\n            self.unk = 0\n            self.idx_to_token += ['']\n        self.idx_to_token += [token for token, freq in self.token_freqs\n                        if freq >= min_freq and token not in self.idx_to_token]\n        self.token_to_idx = dict()\n        for idx, token in enumerate(self.idx_to_token):\n            self.token_to_idx[token] = idx\n\n    def __len__(self):\n        return len(self.idx_to_token)\n\n    def __getitem__(self, tokens):\n        if not isinstance(tokens, (list, tuple)):\n            return self.token_to_idx.get(tokens, self.unk)\n        return [self.__getitem__(token) for token in tokens]\n\n    def to_tokens(self, indices):\n        if not isinstance(indices, (list, tuple)):\n            return self.idx_to_token[indices]\n        return [self.idx_to_token[index] for index in indices]\n\ndef count_corpus(sentences):\n    tokens = [tk for st in sentences for tk in st]\n    return collections.Counter(tokens)  # 返回一个字典，记录每个词的出现次数\n  \n  \nvocab = Vocab(tokens)\nprint(list(vocab.token_to_idx.items())[0:10])\n\n# output: [('', 0), ('the', 1), ('time', 2), ('machine', 3), ('by', 4), ('h', 5), ('g', 6), ('wells', 7), ('i', 8), ('traveller', 9)]\n```\n\n\n\n### 将词转为索引\n\n使用字典，我们可以将原文本中的句子从单词序列转换为索引序列。\n\n```python\nfor i in range(8, 10):\n    print('words:', tokens[i])\n    print('indices:', vocab[tokens[i]])\n    \n# output: \n# words: ['the', 'time', 'traveller', 'for', 'so', 'it', 'will', 'be', 'convenient', 'to', 'speak', 'of', 'him', '']\n# indices: [1, 2, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 0]\n# words: ['was', 'expounding', 'a', 'recondite', 'matter', 'to', 'us', 'his', 'grey', 'eyes', 'shone', 'and']\n# indices: [20, 21, 22, 23, 24, 16, 25, 26, 27, 28, 29, 30]\n```\n\n\n\n### 用现有工具进行分词\n\n我们前面介绍的分词方式非常简单，它至少有以下几个缺点:\n1. 标点符号通常可以提供语义信息，但是我们的方法直接将其丢弃了\n2. 类似“shouldn't\", \"doesn't\"这样的词会被错误地处理\n3. 类似\"Mr.\", \"Dr.\"这样的词会被错误地处理\n\n我们可以通过引入更复杂的规则来解决这些问题.\n\n下面是一个简单的例子：\n\n```python\ntext = \"Mr. Chen doesn't agree with my suggestion.\"\nfrom nltk.tokenize import word_tokenize\nprint(word_tokenize(text))\n\n# output: ['Mr.', 'Chen', 'does', \"n't\", 'agree', 'with', 'my', 'suggestion', '.']\n```\n\n","tags":["Dive系列"],"categories":["NLP"]},{"title":"【GNN】Note：图深度表示基础和前沿进展","url":"/2020/02/10/【GNN】Note：图深度表示基础和前沿进展/","content":"\n![1](【GNN】Note：图深度表示基础和前沿进展/1.jpg)\n\n![2](【GNN】Note：图深度表示基础和前沿进展/2.jpg)\n\n![3](【GNN】Note：图深度表示基础和前沿进展/3.jpg)\n\n![4](【GNN】Note：图深度表示基础和前沿进展/4.jpg)\n\n![5](【GNN】Note：图深度表示基础和前沿进展/5.jpg)\n\n![6](【GNN】Note：图深度表示基础和前沿进展/6.jpg)\n\n![7](【GNN】Note：图深度表示基础和前沿进展/7.jpg)\n\n![8](【GNN】Note：图深度表示基础和前沿进展/8.jpg)\n\n![9](【GNN】Note：图深度表示基础和前沿进展/9.jpg)","tags":["GNN"],"categories":["GNN"]},{"title":"【CS224N】L1. Introduction and Word Vectors","url":"/2020/01/18/【CS224N】L1. Introduction and Word Vectors/","content":"\n![1](【NLP】L1-Introduction-and-Word-Vectors/1.jpg)\n\n![2](【NLP】L1-Introduction-and-Word-Vectors/2.jpg)\n\n![3](【NLP】L1-Introduction-and-Word-Vectors/3.jpg)","tags":["CS224N"],"categories":["NLP"]},{"title":"【CS224N】L6/L7. LM, RNN/LSTM/GRU","url":"/2020/01/18/【CS224N】L6_L7. LM, RNN_LSTM_GRU/","content":"\n# 【CS224N】L6_L7. LM, RNN_LSTM_GRU\n> L6和L7从Language model出发，讲解了NLP中非常常见的RNN以及各种variants。主要包含以下内容：\n>\n> - Language model\n> - RNN\n> - Gradient vanishing/exploding\n> - LSTM\n> - GRU\n> - Bidirectional RNN\n> - Deep RNN\n\n## Language model\n\n语言模型是NLP中的一类任务，它的目的是预测接下来的词将会是什么，即给定前n词，计算出第n+1个词的概率分布。语言模型的应用比较广泛，比如拼音输入法的智能提示，智能纠错等。\n\n<img src=\"【CS224N】L6_L7. LM, RNN_LSTM_GRU/image-20200616235905326.png\" alt=\"image-20200616235905326\" style=\"zoom:50%;\" />\n\n<img src=\"【CS224N】L6_L7. LM, RNN_LSTM_GRU/image-20200616235519607.png\" alt=\"image-20200616235519607\" style=\"zoom:50%;\" />\n\n接下来介绍了多种语言模型\n\n### <u>n-gram Language Models</u>\n\n在deep learning之前，statistical NLP中有n-gram LM。\n\n<img src=\"【CS224N】L6_L7. LM, RNN_LSTM_GRU/image-20200617000941455.png\" alt=\"image-20200617000941455\" style=\"zoom:50%;\" />\n\n接下来是一个具体的4gram LM的例子。\n\n<img src=\"【CS224N】L6_L7. LM, RNN_LSTM_GRU/image-20200617001233748.png\" alt=\"image-20200617001233748\" style=\"zoom:50%;\" />\n\n可以看出，4gram无法看到前面语句中的keywords，丢弃太多句子成分，预测只看语料库的概率分布。\n\n<img src=\"image-20200617001428764.png\" alt=\"image-20200617001428764\" style=\"zoom:33%;\" />\n\n","tags":["CS224N"],"categories":["NLP"]},{"title":"Hello World","url":"/2020/01/11/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]