[{"title":"钱学森：毛泽东成为千古伟人的机理初探","url":"/2020/12/21/【毛选】钱学森：毛泽东成为千古伟人的机理初探/","content":"\n​\t\t\n\n​\t\t二十世纪初，在中国人民处于水深火热之中，中华民族面临生死存亡之际，历史突然改变了轨迹。\n\n　　“东方红，太阳升，中国出了个毛泽东。”他以非凡的胆略与智慧，领导中华民族绝处重生，仅仅用了二十八年时间，就使中国共产党和人民军队从无到有，从小到大，从弱到强，带领全国人民战胜了国内外所有强大的敌人，一雪百年耻辱，建立了新中国，为中华民族屹立于世界强族之林，打下了坚实的基础。\n\n　　当中国人民从列强的宰割与蹂躏中奋然站立起来以后，毛泽东在一穷二白，满目疮痍的一片废墟之上，发下宏愿：中国人民有志气，有能力，一定要在不远的将来，赶上和超过世界先进水平！今天，中国人民正在将毛泽东的伟大理想一步一步地变成现实。\n\n　　然而在我们攀登顶峰的道路上，将会充满艰难与曲折。中国要想后来居上，超过世界领先水平，引领21世纪世界新潮，不仅必须培养和造就一大批新一代中国伟大的思想家，政治家，军事家，企业家，科学家，教育家，而且更为重要的是必须首先造就象毛泽东那样具有敢想，敢干，敢为天下先的胆量和雄才大略的第一流的领袖群体。毛泽东作为生长于中国大地的世界第一流的伟大领袖，为我们研究他的成长历程，探求造就伟大领袖和统帅的培养模式，提供了得天独厚的条件。\n\n　　毛泽东，字润之。1893年12月26日生于湖南湘潭韶山冲一个农民家庭。他13岁前学过四书五经，朝夕诵记中潜移默化了他的心灵。“影响毛泽东性格，塑造毛泽东人生境界的，还有丰富的古典文学名著。象《精忠传》、《隋唐嘉话》、《水浒》、《三国演义》、《西游记》等等，书中古侠们打富济贫的行为，梁山好汉们的造反精神，孙悟空的叛逆性格等”。\n\n　　在13岁时由于认定继续背诵哪些陈腐无用的经书不合自己的心愿，他便决定在家自学了。这时的毛泽东并不知道自己到底该学什么？只是被强烈的求知欲驱动着学习他所能够找到的一切书籍。后来他读到一本郑观应写的讨论社会政治问题的书《盛世危言》，对他的思想产生了强烈震撼。他回忆说，“我读了一本叫《盛世危言》的书，我当时非常喜欢这本书。作者是个老的改良主义者，认为中国之所以弱，在于缺乏西洋的器械-----铁路，电话，电报，轮船，所以想把这些东西引进中国。《盛世危言》激起了我恢复学业的愿望。”\n\n　　毛泽东17岁离家赴湘乡县立东山高等小学求学前夕，写了一首《赠父诗》：“孩儿立志出乡关，学不成名誓不还。埋骨何须桑梓地，人生无处不青山。”这首诗反映出当时的毛泽东是一位很有志气的青年。在东山学校，他从同学那里借了一本《世界英雄豪杰传》。从这本书里，他认识了令他非常钦佩的拿破仑、彼得大帝、卢梭、孟德斯鸠、华盛顿、林肯等人物。他在东山的求学只有短短的半年，1911年辛亥革命爆发后，毛泽东加入湖南起义新军。\n\n　　辛亥革命失败后，他弃武从学。但学什么呢？毛泽东回忆说，“我并没有判断学校优劣的特定标准，也不明确自己究竟想干什么。”他对学校的了解一是报纸广告，二是朋友介绍，“一个警政学校的广告引起我的注意，于是去报名投考。但在考试以前，我看到一所制造肥皂的“学校”的广告，它不收学费，供给膳食，还答应给些津贴。这是一则吸引人鼓舞人的广告。……我改变了投考警校的念头，决定去做一个肥皂制造家。……这时候，我的一个朋友成了学法律的学生，他劝我进他们的学校。我也读了这所法政学堂的娓娓动听的广告。……我写信给家里，重述了广告上所许诺的一切，要求给我寄学费来。……另一个朋友劝告我，说国家正处于经济战争中，当前需要的人材是能够建设国家经济的经济学家。他的议论打动了我，我又花了一元钱向这个商业中学报名。我真的被录取了并在那里注了册。……有一天我读到了个广告，介绍一所公立高级商业学校的优点。……我认为最好能在那里成为一个商业专家，就又付了一块钱报名。……我进了这个学校，但是只耽了一个月。我发现，这所新学校的麻烦之处，在于很多课程都用英语讲授。我和其他学生一样只懂得一点点英语。……我的下一个经历是省立第一中学。我花了一块钱报名，参加了入学考试，发榜时名列第一。……我不喜欢第一中学。它的课程有限，校规也使人反感。我读了《御批通鉴辑览》以后，得出结论：不如独自看书学习。”此后毛泽东住进湘乡会馆，每天到省立图书馆去读书，主要是世界地理和历史。后来实在没有钱了，才又留意广告，考进湖南师范学校，“我在师范学校当了五年学生，并且抵住了后来所有广告的引诱。最后，我居然得到了毕业文凭。”从一九一三年到一九一八年，这是毛泽东一生接受的最正规、最完整的教育。\n\n　　单从以上引述的有关毛泽东就学的的经历来看，可谓乏善可陈。读了六年私塾，一无留洋背景，二无名牌学历。17岁读高小，后来是一联串的技校，而且个个半途而废。25岁才师专毕业。这样一份简历在一般人看来，别说锦绣前程，就是混碗饭吃，也是实属不易。毛泽东的求学经历，为何如此坎坷？因为他内心深处孜孜以求的是超凡脱俗的“内圣外王”之道，天下没有一所学校有能力传授！而这一切只有靠他自己去独立探索。就是在这个探索的过程中，毛泽东逐步形成了非凡的个性，和由此产生的超人的智慧。\n\n　　毛泽东之所以成为伟大的领袖，关键的原因是他在青少年时期培养出了伟大领袖的心理素质。\n\n　　一种高屋建瓴的领袖心态。一个人在青少年时期的性格形成对其以后一生的成就有着决定性的影响。这与其当时的生活环境有着密切的关系。毛泽东如果不是出生在湖南，他的心理发育历程也许会大不相同，中国的历史也可能随之而大不相同。湖南与众不同之处就是在近代出了个曾国藩。正如唐浩明在《曾国藩》一书中描写的那样，曾国藩平定太平军后，十几万湘勇带着从金陵劫掠的大批财富，回到湖南“起屋买田，送子读书，经商跑大码头，出门会阔朋友，开湖南一代新风，遂使历来号称天荒之地的三湘四水，从此眼界大开，风气大变，人才辈出，灿若群星，成为近代中国最有名气，最有影响的一个省份。”在毛泽东的青少年时代，崇仰和学习曾国藩，在湖南青年学子中蔚然成风。莫志斌，陈特水在《跟毛泽东学读书》中披露，青年毛泽东是极为推崇“圣贤”的。他“衡量圣贤的标准，显然是受了曾国藩家书的影响。”曾国藩为教育曾氏子孙，选择了“古今圣哲”周文王，孔孟，司马迁，诸葛亮等33位中国历史上卓有建树的政治家，思想家，史学家，文学家，教育家。青年毛泽东在《讲堂录》中就完整地记录并深入研究了这33位曾国藩选出的“圣哲”，其中多位在毛泽东的早期著作中多次出现。毛泽东特别崇拜曾国藩从修身养性的“内圣”入手，中道致力于经帮治国，治军，“平天下”，从而引向“外王”之道。在青年毛泽东眼里，曾国藩是位既懂“内圣”之道，又获“外王”之绩的“圣贤”人物。在曾国藩的影响之下，加上西学东进的时代感召，和当时中国内忧外患，民不聊生的悲惨境遇，毛泽东逐渐明确了学习的目标，那就是师从古今中外的众多最伟大的人物，修炼“内圣外王”之道，兴邦治国平天下，改天换地救中国！\n\n　　伟大的志向造就了毛泽东非凡的品格。“天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。”为了完成“天降大任”，毛泽东有意识地锻炼自己吃大苦，耐大劳的品格。他和友人一起徒步考察湖南，“身无分文，心忧天下。”沿途乞讨，体察民情。为了培养自己的坚强意志，每遇狂风暴雨，雷电交加，他常赤身露体，呼号狂奔着在峥嵘险峻的岳麓山上奋勇登攀。抒发着战天斗地的万丈豪情。寒冬腊月，冰水浇身。风急浪高，劈波斩浪。风吹浪打，闲庭信步。“一不怕苦，二不怕死。”“与天奋斗，其乐无穷，与地奋斗，其乐无穷，与人奋斗，其乐无穷。”这种青年时代的壮志豪情，在他令人回味无穷壮美诗篇《沁园春。长沙》中得以尽情的展现：\n\n　　独立寒秋，湘江北去，橘子洲头。\n　　​看万山红遍，层林浸染；漫江碧透，百舸争流。\n　　​鹰击长空，鱼翔潜底，万类霜天竞自由。\n　　​怅寥廓，问苍茫大地，谁主沉浮？\n\n　　携来百侣曾游，忆往昔峥嵘岁月稠。\n　　​恰同学少年，风华正茂；书生意气，挥斥方遒。\n　　​指点江山，激扬文字，粪土当年万户侯。\n　　​曾记否，到中流击水，浪遏飞舟？\n\n　　毛泽东顶天立地的豪迈气概在很大的程度上是他胸怀远大抱负，有意识地自我训练的结果。\n\n　　在品格修养中，毛泽东还非常看重成大事者忍辱负重，愈挫愈奋，百折不挠的意志磨练。正是这样的心理素质使他在日后极端艰难困苦的斗争环境中，在受到错误路线打击排挤的逆境中，始终保持昂扬的斗志，领导中国革命，战胜一切艰难险阻，下定决心，不怕牺牲，排除万难，去争取胜利。正是这样的心理素质使他所造就的人民军队具有一种一往无前的气概，它要压倒一切敌人，而决不被敌人所屈服。正是这种气概，铸成了人民军队的军魂。它让世界上最强大的敌人们无不心惊胆寒。\n\n　　毛泽东曾反复研读司马迁在受腐刑之后写给朋友的《报任安书》，并仔细地琢磨司马迁在书中所体现出来的思想境界：“盖文王拘而演周易，仲尼厄而作春秋；屈原放逐，乃赋离骚；左丘失明，厥有国语；孙子膑脚，兵法修列；不韦迁蜀，世传吕览；韩非囚秦，说难、孤愤；诗三百篇，大抵贤圣发愤之所为作也。”毛泽东经常用《报任安书》中的话来教育全党要经得起挫折，要不为逆境所折服，要奋发有为。毛泽东日后考察干部，也特别看中能否经得起挫折这一条。后来邓小平几落几起，终成大业。这与毛泽东除欣赏其才干外，也爱惜其能经得起挫折的品格很有关系。\n\n　　司马迁对毛泽东的另一个重要影响，是司马迁注意读“无字之书”。他20岁以后，游历各地的名山大川，考察史迹，广收史料，对历史的感性认识，为他后来写作《史记》打下了坚实基础。司马迁的“实学”精神令青年毛泽东深受感动，他表示“闭门求学，其学无用。欲从天下国家万事万物而学之”。在司马迁的“实学”精神影响下，毛泽东一生注重实地考察，调查研究，反对本本主义，教条主义，大力提倡理论联系实际的学风。1927年写下著名的《湖南农民运动考察报告》，是其调查研究的典范之作。后来在延安又写了《实践论》。毛泽东理论联系实际的学风，是其获得真知灼见的重要方法。\n\n　　毛泽东伟大的志向在造就其非凡品格的同时，也使他拥有了做为领袖所必备的强大的感召力和凝聚力。张昆弟1917年9月日记曾记述：“毛君云，西人物质文明极盛，遂为衣食住三者所拘，徒供肉欲之发达已耳。若人生仅此衣食住三者而已足，是人生太无值。”（注：《毛泽东早期文稿》，湖南出版社1990年版，第638页。）\n\n　　胸怀大志的青年毛泽东喜欢“读奇书、交奇友、著奇文、创奇迹”。毛泽东自述：“我渐渐聚集了一批学生在我的周围，这些核心成员后来组成一个团体，对中国的大事和命运产生了广泛的影响。这是一群态度严肃的人，无暇谈论琐事。……我和我的朋友只愿意谈论大事——人的本质、人类社会、中国、世界和宇宙。”这些人包括蔡和森、萧子升、何叔衡、张昆弟、萧三、陈昌、周世钊、罗学瓒、彭道良等中国革命运动的先驱。他们组成的团体就是著名的“新民学会”。“《礼记》里的‘大学’篇中有‘道在新民’；《书经》里的‘汤诰’篇中，有‘人作新民’。我们取其‘新民’，意在除旧布新。新的人，新的势力，开一代新风！”\n\n　　不久以后，毛泽东找到了马克思-列宁主义。从此便高举着共产主义这面大旗，凝聚党心，军心，民心，让千百万仁人志士，为实现解放全人类的的伟大目标，甘愿抛头颅，洒热血，为了革命，分身碎骨，心甘情愿！\n\n　　天安门上毛泽东一句话“中国人民从此站立起来了！”全球华人，无不动容！建国之初，毛泽东“超英赶美”一番宏愿，海外赤子，竞相归国。没有汽车洋房，没有金钱美女，只有一张白纸，可以画最新最美的新中国建设蓝图！新中国在一穷二白的基础上，蒸蒸日上，一日千里。今天让我们反思一下，如果共产党领导全国人民的解放事业时，不用解放全人类的的伟大目标为感召，而是用为实现“两亩地，一头牛，老婆孩子热炕头”而奋斗，谁会为之抛头颅，洒热血？头都没了，还想啥？毛泽东如果没有“超英赶美”的宏图大志，而是“衣食住三者而已足”，海外精英们还会有毅然回国的激情吗？毛泽东的伟大，在于其志向的伟大，感召力的伟大，凝聚力的伟大！\n\n　　伟大的志向不仅造就了毛泽东非凡的品格，也造就了毛泽东超人的智慧。毛泽东安邦治国，改天换地的奋斗目标，注定了他只能师从天下最有智慧的那位老师——五千年的历史。1910年毛泽东在私塾里第一次读到了吴乘权等编修的《纲鉴易知录》。这是一部简明中国通史。私塾的学习为他的打下了古文的基础。后来他在湖南省立第一中学里读到了《御批通鉴辑览》。这部书是由臣下将乾隆帝朱笔御批的《资治通鉴》的800条汇编而成。此书的卷首还有乾隆写的序言。学安邦治国何人最有资格当导师？当然是建功立业的帝王。这样的帝王总结出的历史经验，正是那时的毛泽东在冥冥之中苦苦寻找的指路明灯。就是为了读这本史书，他退学了。按照乾隆的指点，毫不犹豫地纵身跳进了浩瀚的历史海洋。从此以后，毛泽东读史成瘾。史书成了他日常生活中须臾不可或缺的重要组成部分。其中《资治通鉴》是他最为欣赏的著作之一。\n\n　　《资治通鉴》是我国古代著名历史学家、政治家司马光和他的助手刘攽、刘恕、范祖禹、司马康等人历时十九年编纂的一部规模空前的编年体通史巨著。\n\n　　《资治通鉴》全书294卷，有考异、目录各三十卷，约300多万字。《资治通鉴》所记历史断限，上起周威烈王二十三年（前403年），下迄后周显德六年（959年），前后共1362年。《资治通鉴》的内容以政治、军事和民族关系为主，兼及经济、文化和历史人物评价，目的是通过对事关国家盛衰、民族兴亡的统治阶级政策的描述，以警示后人。\n\n　　《资治通鉴》自成书以来，历代帝王将相、文人骚客、各界要人争读不止。点评批注《资治通鉴》的帝王、贤臣、鸿儒及现代的政治家、思想家、学者不胜枚举、数不胜数。对《资治通鉴》的称誉，除《史记》之外，几乎没有任何一部史著可与《资治通鉴》媲美。（百度百科）\n\n　　毛泽东评价《资治通鉴》说：“这是一部难得的好书噢！我读了十七遍，每读一遍都获益非浅。”\n\n　　《二十四史》也是毛泽东最爱读的一部史书。该书是由清乾隆钦定的二十四部史局的结果，它以统一的纪传体裁，完整、系统地记录了明亡以前中国几千年的沧桑历史。是中国唯一一部完整的、影响最大、流传最广的官修史总集。全书共有三千二百多卷，八百多册，约有四千万字，可谓包罗万象。毛泽东并非为了鸡毛蒜皮的小事去考证式地读史。而是带着问题读，根据需要读。目的是学习安邦治国平天下之道。\n\n　　当毛泽东将上下五千年的天下兴亡，人世沧桑，尽收眼底，烂熟于胸，融汇贯通之后，终于找到了上帝为历史当裁判，为帝王写评语的感觉。“会当临绝顶，一览众山小”的气势跃然纸上：\n\n　　惜秦皇汉武，略输文采；\n　　​唐宗宋祖，稍逊风骚。\n　　​一代天骄，成吉思汗，只识弯弓射大雕。\n　　​俱往矣，数风流人物，还看今朝。\n\n　　当毛泽东将古往今来无数英雄豪杰的雄才大略，经验教训融入自己的灵魂深处之后，他本人也就成为东方智慧的化身！达到了料事如神，用兵如神的境界！从这个意义上可以说毛泽东通过正确的“修炼”确实达到了“神”一般的境界！\n\n　　这里我们并不想鼓吹神秘主义。而是要探索毛泽东成为千古伟人的机理，从而让毛泽东式的领袖人物能在中华大地上层出不穷！下面我们就通过一些实例来分析历史是如何启发毛泽东的灵感的。\n\n　　毛泽东的许多政策和方略来源于对历史经验的总结。比如《汉书》中《赵充国传》给他留下了深刻的印象。古时边塞有事，京师发兵，粮草运输极为不便，往往兴师动众至边疆，敌已遁逃。汉宣帝神爵元年（公元前61年），赵充国督兵西陲，多次上书，提出“屯田戍边”，寓兵于农的主张，而且身体躬行就地解决军粮，这样可避免长途运输的困难，节省国库开支，以逸待劳，长期戍边。这个主张取得了很好的效果。后来曹操和曾国藩也搞屯田，都取得了很好的效果。这为抗战时期的南泥湾大生产运动，解放后建立新疆生产建设兵团，以及黑龙江军垦农场等重大举措，提供了历史借鉴。（将来有朝一日，中国大举开发非洲或月球什么的，这条仍然可以借鉴。此乃后话。）\n\n　　毛泽东善用兵，其中很多也是从赵充国那里学来的。赵充国主张，“善战者致人，不致于人”。毛泽东将之表达为牢牢掌握战争主动权，“你打你的，我打我的。”赵充国讲，“战无必胜，不苟接刃；攻不必克，不苟劳众。”毛泽东总结为“不打无把握之仗。”赵充国提出“以逸待劳，取胜之道也。”毛泽东概括为“敌进我退，敌驻我扰，敌疲我打，敌退我追。”的十六字方针。\n\n　　赵充国平定西羌少数民族暴乱时，军纪严明，秋毫无犯，保护牧农草地的政策受到牧民的拥戴。这为毛泽东长征路过彝族地区的民族政策提供了示范。赵充国的“严惩首要，胁从不问，善待来使，保护牧民”的民族政策，最终使罕开族不战而降。而与其合谋的先零族的入侵，也因势单力孤而被击破。后来孔明对孟获的七擒七纵，更是将对少数民族的攻心战术发挥到极致。这对毛泽东的民族政策和俘虏政策的制定有重大启示。\n\n　　范忠程在《博揽群书的毛泽东》中，记述毛泽东在《赵充国传》讲到兵法的地方逐一圈划。三个大圆圈的竟达19处之多。从圈点浓密，标记繁多，批语精当来看，毛泽东对赵充国印象极为深刻。\n\n　　毛泽东读《史记。高祖本记》与《史记。项羽本记》，对刘，项二人楚汉相争前后的历史作了认真的思考。毛泽东认为项羽的缺点在于优柔寡断，沽名钓誉，不善纳谏。肯定刘邦了解人民心理，豁达大度，从谏如流，决策对头，用人得当。后来毛泽东在《为人民服务》一文中提到民主人士李鼎铭的“精兵简政”的建议时说：“不管是什么人，只要你说得对，我们就改正，只要你说的对人民有好处，我们就照你的办。”后来又建立了人民政协制度，就是由刘邦这样的历史经验而来。\n\n　　在楚汉相争最关键之际，两军相持于荥阳。楚军切断了刘邦的粮道，刘邦害怕了。请求休战。以让出荥阳来换取项羽承认荥阳以西为汉的领土，项羽不顾谋臣范增的反对，放弃了接近灭汉的胜利，“项王乃与汉约，中分天下，割鸿沟以西为汉，鸿沟而东为楚。”和约签定后，项羽松懈，引兵东去，而刘邦得以喘息，最后打败了项羽。这段历史毛泽东自然是牢记于心，决不会重蹈项羽覆辙。1949年4月，在国民党政府即将垮台之际，重演刘邦故伎，向共产党提出划江分治的主张。毛泽东不顾斯大林的压力，坚决打过长江去，解放全中国。此后，在《中国人民解放军占领南京》的著名诗篇中，阐述了楚汉相争的历史经验：“宜将胜勇追穷寇，不可沽名学霸王。”\n\n　　毛泽东在领导中国革命的战争年代，许多高超的智慧和谋略都是来自于历史的经验和教训。以上所举的仅仅是其中的几个例子。从这个意义上来说，毛泽东的智慧，本质上是中华民族五千年经验和教训的结晶。这就是为什么中国出了个毛泽东的原因。\n\n　　中国的历史虽然为战争和谋略提供了大量借鉴，但是在社会主义现代化经济建设，特别是经济战略方面，却是一片空白。只有苏联一种模式。毛泽东是在不断的实践中，几乎从头摸索。而不是在大量历史经验的指引下，胸有成竹。这就是为什么同样一个毛泽东在战争年代才华横溢，而经济建设中却有失误的主要原因，这也正是这位伟人的历史局限之所在。\n\n　　在二十一世纪中华民族伟大复兴的新长征路上，我们不仅面临着超级军事强国，也面临着它的超级经济和科技实力。小小寰球，两只猛虎，早晚会有一决高下的时候。中华民族要想后来居上，必须要技高一筹，未来的竞争既是实力的竞争，更是智慧的竞争，是人才的竞争，但归根到底是领袖之间的较量。正所谓“强将手下无弱兵”。楚汉相争，成败的关键取决于刘邦，项羽领导水平之高下。历史的经验一再证明，弱者可能打败强者，关键在于统帅。\n\n　　“导师伟业垂千古，长征接力有来人。”“长江后浪推前浪，一代更比一代强。”未来中国的领袖们，应当学习毛泽东，研究毛泽东，超越毛泽东。批量造就新一代的毛泽东。关键要抓住两个方面，首先是要有远大的抱负，中华民族决不会甘为人后。\n\n　　伟大的目标产生伟大的动力，伟大的目标产生伟大的创造力，伟大的目标产生伟大的号召力，伟大的目标产生伟大的凝聚力。只有鼓足干劲，力争上游，发奋图强，科学谋略，才能在不久的将来赶上和超过世界顶尖水平！\n\n　　一是要继承和发扬天不怕，地不怕，不信鬼，不信邪，敢于斗争，敢于胜利，压倒一切敌人，而决不被敌人所屈服的大无畏的毛泽东精神。二是要大量研究谋略，不仅是中国的谋略，更要加强研究西方的谋略，特别是经济谋略。未来的主战场更有可能是在经济领域展开。\n\n　　什么是领袖，领袖就是谋万世者，领袖们的谋略从哪里来，毛泽东的伟大成就表明，其过人的智慧主要来自于对中华五千年谋略史的正确总结。靠的是对历史上的大量实例分析来积累经验。这和诸葛孔明初出茅庐便能够大展宏图是一个道理。中国未来的领袖们需要在这个基础上，再加上精通千百年以来的西方经济谋略史。最后创造出结合双方优势的中西合璧的新的谋略体系。从而占领未来竞争中的智慧制高点。让五星红旗高高飘扬！","tags":["思想"],"categories":["毛泽东选集"]},{"title":"美团HR面","url":"/2020/11/12/美团HR面/","content":"## 对美团的了解\n\n美团是中国领先的生活服务电子商务平台，秉承“帮大家吃得更好，生活更好”的使命，在餐饮、外卖、酒店旅游等领域具有领先的市场地位。\n\n\n\n## 职业规划\n\n​\t\n\n## 对岗位的理解\n\n算法工程师的本质是工程师，既然是工程师就要重视代码开发的效率和质量，这样做出来的模型才会更加地保质保量，在团队合作的时候也能减少时间成本。\n\n同时，区别于软件开发，算法岗是一个需要不断超越过去的自己的岗位，也是一个需要不断补充能量提高能力的岗位，需要一直跟进相关领域的最新研究，思考是否可以落地在自己所在的业务环境里。\n\n最后，每个职位每个人在企业里都不是孤立的，算法工程师也是如此，需要多和业务人员、产品经理、数据分析师以及算法的同仁们交流，更深刻的理解业务，也更确保自己在正确的航道上工作。\n\n## 期望薪资\n\n我希望可以拿到27k，最低也要有个24k，当然最终还是要看公司的安排。（就像我说的，我很看重美团的）\n\n有相关的top厂实习经验，而且也有top研究发表，尽管只学习了机器学习一年多，但是有了以上的成果我认为是值得肯定的。\n\n## 家庭情况\n\n父亲、母亲、独生--》独立\n\n## 怎么看待加班\n\n1. 我是一个有责任意识的人，我希望我做的project是一个高质量高标准的项目，因此我会为了项目的顺利开展来主动的加班；\n2. 职业生涯的前期，有很多东西可以向前辈们学习，也可以有更多时间总结反思当天的学习、遇到的问题等等，来让自己变得更厉害；\n3. 我可以接受工作日的加班，但我真的很希望有双休，我认为家庭是生活极其重要的一个部分，就像美团的理念，让每个人吃得更好，生活更好，我也希望我可以生活更好。周末双休可以放松我的心情，也让我可以在下一周更积极的投入到工作中。\n\n## 为什么从华为离职\n\n1. 本来就想读书，家里有变故决定gap；\n2. 到学校来招聘 + 直系学长推荐；\n3. 到了公司就和经理有了沟通，对方也支持。\n\n## 找工作看中什么 & 为什么选择美团\n\n1. 平台大。希望职业生涯从一个高的起点开始走，因为大的平台意味着成就自我的机会更多，而且项目管理、人员管理更加规范，在这一点上，美团的市值现在在互联网行业内仅次于阿里和百度，而且美团的技术氛围也比较浓，技术实力也很强。\n2. 对新人的培养。据我了解，业界对于美团和百度两家公司的新员工培训是颇有好评，我希望我从校园人转身到职业人的这个过程可以得到像美团这样的公司准备的精心培养，让我可以得到更好的发展。\n\n## 个人优缺点、不足\n\n我认为我的优点主要是三个方面：\n\n1. 未雨绸缪。我会提前学习、储备将来可能会用得到的知识技能。例子1，华为离职后；例子2，现在在深入理解c++。\n2. 责任意识。项目owner精神，一旦接手了某个项目或者某个模块就一定尽全力做到最好，聚焦对项目的质量；\n3. 善于与人相处。为人谦虚，温和，从之前在华为的各种部门内和跨部门的会议沟通来看，可以与各种人都有比较高质量的交流。\n\n以上就是我认为我的一些优点\n\n\n\n我的缺点：\n\n有时候容易陷入细节，而就是因为过于在意一些细节，所以可能会浪费一些时间。\n\n\n\n## 最大的挑战\n\n是我在大二下的时候，刚加入我们学院的一个机器人俱乐部，没多久就接到任务要参加奥康皮鞋厂的机器人舞蹈表演。他这个皮鞋厂当时是要资助我们学校的贫困生，所以我们需要安排这么一个表演。当时还是比较有压力的，因为刚接触不久，又是一个比较正式需要有一个高规格的演出任务，所以是一个不小的挑战。我们组一共是五个同学，有经验的学长们都去实习或者开始准备考研了，因此我们要挑起这个重担。我们五个人用了两周，每天除了下课就是呆在实验室，不断调试机器人的动作以及舞蹈的连贯性。时常宿舍关大门了还没回寝室。面对层出不穷的技术性问题，我们也是不断想办法解决\n\n1. 向已经毕业、在实习的学长请教；\n2. 跟机器人厂商发邮件咨询；\n\n终于，最后保质保量的完成了演出，也得到了校领导和奥康老总的认可。\n\n这次挑战主要是时间紧、任务重，自己又经验欠缺，但我也因此提高了自己的抗压能力，团队合作沟通的能力，专业技能也得到了充分锻炼。\n\n## 最有意义的事情\n\n奥康皮鞋\n\n\n\n## 最失败的事情\n\n我想说的是在华为的一段经历。刚从学校到职场，我在工作的时候还是有学生思维，就是leader布置啥，我就做啥，别的东西不再花费时间去了解去学习，没有积极的去承担任务。在第一个月月末的交流会中，导师给了我B+的评级，当时有一个加入重点项目组的机会，也没有邀请我去。我其实比较不解，因为我各项任务都有完成。当时心情比较低落，因为在学校里都比较顺利，任务完成的好都能有一个比较高的评价，因此我也比较困惑，不知道为啥会这样，觉得是不是自己有点失败，所以我又去私下找导师沟通，向他寻求一些建议和指导，他告诉我工作中要及时反馈自己工作中的问题和进度，也要主动去承担新的工作任务，这样才能更快更好的做项目。\n\n听了他的建议之后，我知道了自己学生思维的问题所在，所以在接下来的工作中，我都高效的完成自己任务，然后积极承担新任务，有阻塞的时候也及时反馈。由于我之后的一个工作态度的转变，组里人都对我很认可，之后的评级都是A，最终也以新员工的身份加入到重点项目组中。\n\n通过这次失败的经历，我学到了很多东西：\n\n1. 学会听取别人的建议；\n2. 保持主观能动性；\n\n只有这样才能获得比较好的工作效果。\n\n谢谢\n\n\n\n## 反问\n\n1. 培养体系\n2. 多久出结果"},{"title":"【GNN】Node2Vec","url":"/2020/09/28/【GNN】Node2Vec/","content":"\n\n## 基于BFS邻域的LINE\n\n待补充\n\n\n\n## 基于DFS邻域的DeepWalk\n\n### 中心思想\n\nWord2Vec是一种常用的word embedding方法，Word2Vec通过语料库中的句子序列来描述词与词的共现关系，进而学习到词语的向量表示。\n\nDeepWalk的思想类似word2vec，使用**图中节点与节点的共现关系**来学习节点的向量表示。那么关键的问题就是如何来描述节点与节点的共现关系，DeepWalk给出的方法是使用随机游走(Random Walk)的方式在图中进行节点采样。Random Walk是一种**可重复访问已访问节点的深度优先遍历**算法。给定当前访问起始节点，从其邻居中随机采样节点作为下一个访问节点，重复此过程，直到访问序列长度满足预设条件。\n\n### 训练过程\n\nDeepWalk算法主要包括两个步骤，第一步为随机游走采样节点序列，第二步为使用skip-gram学习表达向量。\n\n1. 构建同构网络，从网络中的每个节点开始分别进行Random Walk 采样，得到局部相关联的训练数据； \n2. 对采样数据进行skip-gram训练，将离散的网络节点表示成向量化，最大化节点共现，使用Hierarchical Softmax来做超大规模分类的分类器。\n\n\n\n## Node2Vec\n\n### 中心思想\n\nNode2Vec是一种综合考虑DFS邻域和BFS邻域的graph embedding方法。简单来说，可以看作是deepwalk的一种扩展，是结合了DFS和BFS随机游走的deepwalk。\n\n设 $f(u)$ 是将顶点 $u$ 映射为embedding向量的映射函数，对于图中每个顶点 $u$ 定义 $N_s(u)$ 为通过采样策略 $S$ 采样出的顶点 $u$ 的近邻顶点集合。<u>**node2vec优化的目标是给定每个顶点条件下，令其近邻顶点（如何定义近邻顶点很重要）出现的概率最大。**</u>\n\n<img src=\"image-20200928225904191.png\" alt=\"image-20200928225904191\" style=\"zoom:60%;\" />\n\n为了将上述最优化问题可解，文章提出两个假设：\n\n- 条件独立性假设\n\n  假设给定源顶点下，其近邻顶点出现的概率与近邻集合中其余顶点无关。\n\n  <img src=\"image-20200928230047605.png\" alt=\"image-20200928230047605\" style=\"zoom:50%;\" />\n\n- 特征空间对称性假设\n\n  这里是说一个顶点作为源顶点和作为近邻顶点的时候共享同一套embedding向量。在这个假设下，上述条件概率公式可表示为：\n\n  <img src=\"image-20200928230218609.png\" alt=\"image-20200928230218609\" style=\"zoom:50%;\" />\n\n根据以上两个假设条件，最终的目标函数表示为：\n\n<img src=\"image-20200928230314007.png\" alt=\"image-20200928230314007\" style=\"zoom:50%;\" />\n\n由于归一化因子 $Z_u$的计算代价高，所以采用负采样技术优化。\n\n### 顶点序列采样策略\n\nnode2vec依然采用随机游走的方式获取顶点的近邻序列，不同的是node2vec采用的是一种有偏的随机游走。\n\n给定当前顶点 $v$，访问下一个顶点$x$的概率为：\n\n<img src=\"image-20200928230833882.png\" alt=\"image-20200928230833882\" style=\"zoom:30%;\" />\n\n$\\pi_{vx}$是顶点 $v$ 和顶点 $x$ 之间的未归一化转移概率，$Z$ 是归一化常数。\n\nNode2Vec引入两个超参数 $p$ 和 $q$ 来控制随机游走的策略，假设当前随机游走经过边 $(t,v)$ 到达顶点 $v$。设 $\\pi_{vx} = \\alpha_{pq}(t,x)·w_{vx}$ ，$w_{vx}$是顶点 $v$ 和 $x$ 之间的边权，![[公式]](https://www.zhihu.com/equation?tex=d_%7Btx%7D) $d_{tx}$为顶点 $t$ 和顶点 $x$ 之间的最短路径长度。\n\n<img src=\"image-20200929093514729.png\" alt=\"image-20200929093514729\" style=\"zoom:30%;\" />\n\n参数 $p$ 控制重复访问刚刚访问过的顶点的概率。注意到 $p$ 仅作用于 $d_{tx}=0$ 情况，而 $d_{tx}=0$ 表示顶点 $x$ 就是访问当前顶点之前刚刚访 $v$ 问过的顶点。 那么若 $p$ 较高，则访问刚刚访问过的顶点的概率会变低，反之变高。\n\n参数 $q$ 控制着游走是向外还是向内，若大于1，随机游走倾向于访问和 $t$ 接近的顶点(偏向BFS)。若小于1，倾向于访问远离 $t$ 的顶点(偏向DFS)。\n\n下面的图描述的是当从 $t$ 访问到 $v$ 时，决定下一个访问顶点时每个潜在目标对应的 $\\alpha$。\n\n<img src=\"image-20200929094206605.png\" alt=\"image-20200929094206605\" style=\"zoom:40%;\" />"},{"title":"【NLP】ERNIE","url":"/2020/09/25/【NLP】ERNIE/","content":"# ERNIE\n\n\n\n## 词的语义表示\n\nWord embedding  通过NNML/CBOW/Skip-gram网络来学习\n\n➡️ 浅层预训练模型  COVE/ELMO\n\n➡️ 深层预训练模型  BERT/ERNIE/XLNET\n\n\n\n## ERNIE的原理介绍\n\n### BERT的缺陷\n\nBERT的预训练任务Mask LM进行了强行掩码，把词与词、字与字之间的关系拆散了。如“哈尔滨”掩码掉“尔”，这样就会缺失信息。\n\n### ERNIE 1.0 对此的改进\n\nMask整个词语、短语、命名实体，相当于**引入了语言知识**。\n\n### ERNIE 2.0\n\n<img src=\"image-20200925171744291.png\" alt=\"image-20200925171744291\" style=\"zoom:50%;\" />\n\n#### 构建多种层次的任务来全面捕捉预料中词法、语义、结构的潜在知识\n\n<img src=\"image-20200925223843670.png\" alt=\"image-20200925223843670\" style=\"zoom:50%;\" />\n\n- 词法层次：知识预测\n- 结构层次：句子排序\n- 语义层次：句子逻辑关系预测（因为所以、如果就...）\n- 加入task vector来指示是什么任务\n\n#### 具体任务的网络实现\n\n<img src=\"image-20200925155509984.png\" alt=\"image-20200925155509984\" style=\"zoom:50%;\" />\n\n#### ERNIE的encoder\n\n核心：Transformer encoder的self attention机制\n\n#### ERNIE的多任务学习策略\n\n- 策略一：顺序学习\n  - 部分任务的语义信息允许递进式的学习，如预测被盖住的词、被盖住的字、被盖住的命名实体；\n  - 好处是容易训练；\n  - 缺点是容易产生遗忘；\n- 策略二：多卡并行下的多任务学习\n  - batch内、batch间都进行多任务的切换；\n\n\n\n## ERNIR应用场景\n\n#### 搜索问答Query识别和QP匹配\n\n分为两个部分。\n\n第一先对query做文本分类，即用户的输入是不是可以被看成一个有答案的问题。先用小规模的有标注数据fine-tune一下ERNIE，然后用ERNIE来标注海量数据，再用这些有标注数据训练一个想对简单的神经网络。即老师通过少量有答案的习题可以学得很好，进而可以在题海中给出正确答案，学生从题海中学习出简单、有效的新模型。\n\n<img src=\"image-20200925161434910.png\" alt=\"image-20200925161434910\" style=\"zoom:50%;\" />\n\n第二，在QP匹配环节，首先用小规模的有标注数据fine-tune一下ERNIE，其输入就是QP pair的形式，通过CLS标记来获取P是不顺匹配Q。然后用这个微调后的模型来对海量数据进行标注，使用标注后的数据训练双塔模型，通过cos来计算相似度分数。\n\n\n\n## ERNIE轻量化技术\n\n### 思路1：ERNIE Tiny\n\n<img src=\"image-20200925224442089.png\" alt=\"image-20200925224442089\" style=\"zoom:50%;\" />\n\n### 思路2：ERNIE Slim\n\n<img src=\"image-20200925224634128.png\" alt=\"image-20200925224634128\" style=\"zoom:50%;\" />\n\n## ERNIE的最新进展\n\n### ERNIE-GEN：利用ERNIE来做自然语言生成\n\n\n\n"},{"title":"阅读《乘风破浪的PTM：两年来预训练模型的技术进展》","url":"/2020/09/23/阅读《乘风破浪的PTM：两年来预训练模型的技术进展》/","content":"# 阅读《乘风破浪的PTM：两年来预训练模型的技术进展》\n\n\n\n## 什么是预训练？\n\n在Transformer作为特征抽取器基础上，选定合适的模型结构，通过某种自监督学习任务，逼迫Transformer从大量无标注的自由文本中学习语言知识。这些语言知识以模型参数的方式，存储在Transformer结构中，以供下游任务使用。\n\n\n\n## 预训练模型中的强基准：RoBERTa\n\n严格来说，原始的Bert模型是个未完成的半成品，而RoBERTa才是遵循Bert思路的完成品。\n\n为什么这么说呢？因为，我们可以把RoBERTa看作是得到充分训练的Bert模型，而原始版本的Bert模型训练不够充分，这种模型是否得到充分训练的微小差异，能够极大提升原始版本Bert模型的效果。\n\n<img src=\"image-20200923150605717.png\" alt=\"image-20200923150605717\" style=\"zoom:50%;\" />\n\n在原始Bert模型的基础上，RoBERTa通过实验，证明了如下几点：\n\n1. 进一步增加预训练数据数量，能够改善模型效果；\n2. 延长预训练时间或增加预训练步数，能够改善模型效果；\n3. 急剧放大预训练的每个Batch的Batch Size，能够明显改善模型效果；\n4. 拿掉预训练任务中的Next Sentence Prediction子任务，它不必要存在；\n5. 输入文本的动态Masking策略有帮助；\n\n\n\n## 预训练模型的整体架构们\n\n对于预训练模型来说，目前的主流模型大都采用Transformer作为特征抽取器，现阶段看，Transformer的潜力仍然没有被充分挖掘，还有很大潜力可挖，意思是，Transformer效果足够好，而且还可以更好，貌似改进Transformer并非当务之急的事情。<u>**预训练模型的知识，是通过Transformer在训练迭代中从数据中不断学习，并以模型参数的形式编码到模型中的。**</u>虽然，大家都是用的Transformer，但是怎么用它搭建模型结构学习效率更高？这是一个问题。所谓学习效率高，就是给定相同大小规模的训练数据，它能编码更多的知识到模型里，这就意味着它的学习效率更高。<u>**不同的Transformer用法，会产生不同的模型结构，就会导致不同结构的差异化的学习效率。**</u>\n\n\n\n### <u>Encoder-AE</u> ALBert, RoBERTa\n\n#### 结构\n\n<img src=\"image-20200927211436942.png\" alt=\"image-20200927211436942\" style=\"zoom:50%;\" />\n\nEncoder-AE结构如上图所示。这其实是包括原始版本Bert在内的，大多数后续改进模型采取的结构。整个结构就是一个标准的Transformer，在语言模型预训练的时候，采用AE方法。也就是说，输入句中的未被Mask的任意单词两两可见，但是被Mask掉的单词之间都相互独立，互不可见。在预测某个被Mask掉的单词的时候，所有其它被Mask的单词都不起作用，但是句内未被Mask掉的所有单词，都可以参与当前单词的预测。可以看出，Encoder-AE是个采用双向语言模型的单Transformer结构。\n\n#### 效果\n\n从对比实验看，除了Encoder-Decoder结构外，对于语言理解类的NLP任务，这种结构都是效果最好的，但是对于语言生成类的任务，这种结构效果相对很差。也就是说，这种结构比较适合做语言理解类的任务。\n\n\n\n### <u>Decoder-AR</u> GPTs\n\n#### 结构\n\n<img src=\"image-20200927211456461.png\" alt=\"image-20200927211456461\" style=\"zoom:50%;\" />\n\nDecoder-AR结构如上图所示。它和Encoder-AE结构相同，都是采用单个的标准Transformer，主要区别在于：语言模型预训练的时候，采用AR方法，就是从左到右逐个生成单词，第i个单词只能看到它之前的第1到第 (i-1) 个单词 ，不能看到后面的单词。采用这种结构的典型模型就是GPT系列。\n\n#### 效果\n\n除了Encoder-Decoder结构外，貌似对于语言生成类的任务，这种结构是效果最好的结构之一。但是相应的，语言理解类的任务，采用这种结构，效果比Encoder-AE结构差距非常明显，这也好理解，因为只看到上文看不到下文，对于很多语言理解类任务而言，信息损失很大，所以效果不好也在情理之中。也就是说，这种结构比较适合做语言生成类的任务。\n\n\n\n### <u>Encoder-Decoder</u> Google T5/BART\n\n#### 结构\n\n<img src=\"image-20200927211829269.png\" alt=\"image-20200927211829269\" style=\"zoom:30%;\" />\n\nEncoder-Decoder结构如上图所示。这种结构在Encoder侧，单独使用一个Transformer，采用了Encoder-AE的结构。也就是说，编码阶段采用双向语言模型，任意两个单词两两可见，以更充分地编码输入信息；而在Decoder侧，使用另外一个Transformer，采用了Decoder-AR结构，从左到右逐个生成单词。\n\n当然，Decoder侧和标准的Decoder-AR不同的地方还是有的：Decoder侧生成的单词 ，除了像Decoder-AR结构一样能看到在它之前生成的单词序列外，还能看到Encoder侧的所有输入单词 。而这一般是通过Decoder侧对Encoder侧单词，进行Attention操作方式来实现的，这种Attention一般放在Encoder顶层Transformer Block的输出上。\n\n<u>在进行预训练的时候，Encoder和Decoder会同时对不同Mask部分进行预测：Encoder侧双向语言模型生成被随机Mask掉的部分单词；Decoder侧单向语言模型从左到右生成被Mask掉的一部分连续片断。两个任务联合训练，这样Encoder和Decoder两侧都可以得到比较充分地训练。</u>？\n\n#### 效果\n\n从目前对比实验看，无论是语言理解类的任务，还是语言生成类的任务，Encoder-Decoder结构相对其它几种结构来说，效果都是最好的之一。而且，它有另外一个优点，就是用这个结构，可以同时做生成类和理解类的NLP任务，基本做到了不同任务在模型结构上的统一，这点还是很好的，一个结构可以到处使用，比较方便。但是，它也有个问题，因为两侧各用了一个Transformer，所以相对其它结构参数量翻倍，计算量也增加了，就是说比其它模型笨重。而且，Encoder-Decoder结构比其它结构效果好，很可能主要原因来自于参数量增加导致的模型容量增大，当然这是个人猜测。目前，采用这个结构的效果很好的模型包括Google T5以及BART等模型。\n\n\n\n### <u>Prefix LM</u> UniLM\n\n<img src=\"image-20200927214210491.png\" alt=\"image-20200927214210491\" style=\"zoom:45%;\" />\n\n#### 结构\n\nPrefix LM结构是Google T5论文中给出的叫法，这种结构最早由UniLM模型提出，我们沿用Google T5的这种称谓。\n\n如果深入分析的话，Prefix LM其实是Encoder-Decoder模型的变体：Prefix LM的Encoder和Decoder通过分割的方式，分享了同一个Transformer结构，Encoder部分占用左部，Decoder部分占用右部，这种分割占用是通过在Transformer内部使用Attention Mask来实现的。与标准Encoder-Decoder类似，Prefix LM在Encoder部分采用AE模式，就是任意两个单词都相互可见，Decoder部分采用AR模式，即待生成的单词可以见到Encoder侧所有单词和Decoder侧已经生成的单词。\n\n#### 效果\n\n在其它条件相同的情况下，关于语言理解类的任务（参考Encoder-AE部分Google T5论文中的相关实验），Prefix LM结构的效果要弱于标准Encoder-Decoder结构。这里是值得深入思考下的，因为看上去Prefix LM和标准的Encoder-Decoder结构是等价的。那么，为什么它的效果比不过Encoder-Decoder结构呢？我想，一方面的原因估计是两者的参数规模差异导致的；另外一方面，可能与它这种模式的Decoder侧对Encoder侧的Attention机制有关。<u>在Decoder侧，Transformer的每层 Block对Encoder做Attention的时候，标准的Encoder-Decoder模式，Attention是建立在Encoder侧的最后输出上，这样可以获得更全面完整的全局整合信息；而Prefix LM这种结构，Decoder侧的每层Transformer对Encoder侧的Attention，是建立在Encoder的对应层上的，因为这种模式的Encoder和Decoder分割了同一个Transformer结构，Attention只能在对应层内的单词之间进行，很难低层跨高层。</u>这可能是影响这种结构效果的原因之一。当然这只是个人猜测，无证据证明，还请谨慎参考。\n\n关于语言生成类的任务，Prefix LM效果虽然要弱于Encoder-Decoder结构（参考Encoder-Decoder小节UniLM v2论文效果对比图），但是总体而言，两者相差不大，相对其它模型，Prefix LM结构在生成类任务表现也比较突出。\n\nPrefix LM因为是Encoder-Decoder的变体，所以可以看出，它的优势也在于可以同时进行语言理解和语言生成类任务，而且相对Encoder-Decoder来说，因为只用了一个Transformer，所以模型比较轻，这是Prefix LM的优势。缺点则是在效果方面，貌似要弱于Encoder-Decoder模型的效果，语言理解类任务相对有明显差距，生成类任务的效果相差不大。\n\n\n\n### <u>Permuted Language Model</u>  XLNet\n\n#### 结构\n\nPLM一样采用单个Transformer模型作为主干结构，但是从训练方法上来说，是个很另类也很有创意的做法，是种“形为AR，实为AE”的做法。在语言模型预训练过程中，它看上去遵循AR从左到右的输入过程，这符合一般生成任务的外在表现形式，但是在内部通过Attention Mask，实际做法其实是AE的做法，无非是把AE的做法隐藏在Transformer内部。\n\n它和AE从细节来说，主要有两个区别：首先，预训练过程中，输入句子去掉了Mask标记，改为内部Attention Mask，以保持预训练过程和下游任务Fine-tuning的一致性。关于这一点，目前有实验证明这个虽然有积极影响，但是影响不大；其次，也是它和AE的最主要区别，PLM认为被Mask掉的单词之间是相互有影响的，先产生的被Mask掉的单词，应该对后生成的被Mask掉的单词，在预测的时候发生作用，而标准的AE则认为被Mask掉的单词是相互独立的，相互之间不产生作用。\n\n<img src=\"image-20200927215928079.png\" alt=\"image-20200927215928079\" style=\"zoom:50%;\" />\n\n本质上PLM是Prefix LM的一种变体。上图给出了个例子来说明这种情况，对于某个输入句子，PLM首先会进行单词顺序随机变换，然后选定变换后句子的末尾一部分单词进行Mask，被Mask的单词预测顺序是有序的，按照变换后在句中先后顺序来预测，上面例子中会先预测$x_1$，然后再预测$x_5$。在预测 $x_1$的时候，未被Mask的上下文$x_2, x_3, x_4$会对预测$x_1$有帮助；假设已经预测并输出了$x_1$ ，在预测$x_5$的时候，未被Mask掉的上下文$x_2, x_3, x_4$，以及刚预测出的$x_1$ ，会对预测$x_5$有帮助。其实你想，这等价于什么？等价于以 $x_4$作为边界切割开的Prefix LM模型，Encoder端包含$x_2, x_3, x_4$，Decoder侧包含$x_1, x_5$。当然，因为每个输入句子的长度各异，被Mask掉的单词个数也不固定，所以看上去Encoder和Decoder的边界根据输入句子，边界是在动态变化的。所以，PLM其实是一种边界变化的Prefix LM变体结构。\n\n#### 效果\n\n如果不考虑XLNet里的其它因素，单纯看PLM结构的话，目前有些对比；在语言生成类任务中，效果略微优于Encoder-AE，但是距离Decoder-AR差距较大。在两类任务中，都有点上不着村，下不着店的感觉，就是都还可以，但都不够好的感觉。XLNet效果确实是很好的，但是，这说明XLNet效果好，真正起作用的貌似不是PLM，而是其它因素。\n\n\n\n\n\n## 促进模型性能快速提高的因素\n\n#### 更高质量、更多数量的预训练数据\n\n这点其实从Bert一出来，就是一个容易想到的重要因素。因为数据量越多，数据里蕴含的知识也越多，那么模型能学到的东西越多，所以模型效果会更好，这是一个靠简单推理就能得出的结论。但是，它是有前提的，前提是数据质量要高，光数据量大不行，很多乱七八糟的数据，反而会对模型效果带来负面影响。\n\n#### 增加模型容量及复杂度\n\n所谓增加模型容量及复杂度，指的是增加Transformer模型的参数量，一般而言，模型容量越大，模型的表达能力越强。**最直接的增加模型容量的方式就是增加Transformer Block层深**，比如可以从Bert base的12层，增加到Bert Large的24层，还可以继续增加到比如36层，这是纵向增加复杂度，Google T5走的这条路，模型容量增加到4倍后，有些数据集效果相对Baseline有大幅度的提升。**除此外，还可以横向增加模型复杂度，比如在固定Transformer层深的情况下，可以通过放大Transformer中构件的大小，比如Hidden Size的增大，FFN层对隐层的放大，Multi-Head Self Attention的Attention头的增加，**等多种方式来做到这一点。ALBERT走的这条路，它的xxLarge模型效果最好，只用了12层Transformer Block，但是Hidden Size达到了4096。\n\n这两种模式还可以相互结合，就是同时纵向和横向增加模型复杂度，GPT 3即是如此，将模型复杂度这点推到了极致。**需要注意的是，单词特征的Embedding不会放的太大，一般采用64或者128大小，ALBERT证明了如果单词特征Embedding跟着Transformer内部的Hidden Size同步放大，效果反而会降低。**也就是说，增加模型容量指的是放大Transformer模型本身的参数量，但不包括输入层Embedding的参数。\n\n#### 更充分地训练模型\n\n放大Batch Size、增加预训练步数，就是RoBERTa做的那两个事情。\n\n#### <u>有难度的预训练任务</u>\n\n原始的Bert预训练，有两个训练任务：一个是单词级的Mask语言模型MLM，一个是句子级的下一句预测任务NSP。RoBERTa证明了NSP对于模型效果没什么影响，所以拿掉了这个任务。有很多研究集中在这一块，采取了五花八门的预训练任务。那么哪些预训练任务相对而言更有效呢？目前已经能够得出些比较明确的结论。\n\n对于单词级的Mask语言模型来说，Span类的预训练任务效果最好。所谓Span类的任务，就是Mask掉的不是一个独立的单词，而是一个连续的单词片断，要求模型正确预测片断内的所有单词。Span类任务，只是一个统称，它会有一些衍生的变体，比如N-Gram，就是Span模型的一个变体，再比如Mask掉的不是单词而是短语，本质上也是Span类任务的变体，这里我们统称为Span类任务。\n\nhttps://www.nowcoder.com/discuss/244739?type=post&order=time&pos=&page=1\n\n\n\n### 如何建造强大的预训练模型\n\n对于语言理解类任务，我假设你的任务不是领域性特别强那种类型的，建议采取如下技术方案：\n\n使用三阶段模型：通用预训练+任务预训练+任务Fine-tuning。在做完第一阶段预训练后，用手头任务数据，抛掉标签，再做一次任务预训练，然后任务Fine-tuning。\n\n模型结构建议采取Encoder+Decoder结构，或者Encoder-AE结构；预训练任务配置两个：独立生成Span类语言模型及SOP句子任务；在质量优先的前提下，增加预训练数据的数量；比较关键的一点是，一定要增加模型容量：可以纵向增加Transformer Block层深，或者横向调大Transformer相应位置可配置参数大小。当然，如果你不差钱，两个可以一起上。另外，要使得模型得到充分训练，就是说增大训练过程中的Batch Size和训练步长。\n\n对于语言生成类任务，建议采取如下技术方案：\n\n使用两阶段模型：通用预训练+任务Fine-tuning。模型结构建议采取Encoder+Decoder结构，或者Decoder-AR结构；预训练任务采用独立生成Span类语言模型；在质量优先的前提下，增加预训练数据的数量；同样，比较关键的一点是，一定要增加模型容量：可以纵向增加Transformer Block层深，或者横向调大Transformer相应位置可配置参数大小。当然，如果你不差钱，两个可以一起上。另外，也要使得模型得到充分训练，就是说增大训练过程中的Batch Size和训练步长。"},{"title":"XGBoost面试题总结","url":"/2020/07/23/XGBoost面试题总结/","content":"\n本文对`XGBoost`的面试题进行梳理，需要首先对`GBDT`/`XGBoost`/`Ensemble Learning`有一定的了解、\n\n#### 简单介绍一下XGBoost\n\nXGBoost是一种boosting的方法，其核心思想为每一棵树都是对之前的拟合残差的再拟合，直到残差足够小。XGBoost的基分类器可以由用户选择树或者线性，损失函数也可以自定义，只需要满足二阶可导即可。XGBoost对GBDT进行了一系列优化，比如损失函数进行了二阶泰勒展开、目标函数加入正则项、支持并行和默认缺失值处理等，在可扩展性和训练速度上有了巨大的提升，但其核心思想没有大的变化。\n\n---\n\n#### XGBoost和GBDT的区别是什么？\n\n- **基分类器**：XGBoost的基分类器不仅支持CART决策树，还支持线性分类器，此时XGBoost相当于带L1和L2正则化项的Logistic回归（分类问题）或者线性回归（回归问题）。\n- **导数信息**：XGBoost对损失函数做了二阶泰勒展开，GBDT只用了一阶导数信息，并且XGBoost还支持自定义损失函数，只要损失函数一阶、二阶可导。\n- **正则项**：xgboost在代价函数里加入了正则项，用于控制模型的复杂度。正则项里包含了树的叶子节点个数、每个叶子节点上输出的score的L2模的平方和。从Bias-variance tradeoff角度来讲，正则项降低了模型的variance，使学习出来的模型更加简单，防止过拟合，这也是xgboost优于传统GBDT的一个特性。\n- **列抽样**：XGBoost支持列采样，与随机森林类似，用于防止过拟合。\n- **缺失值处理**：对树中的每个非叶子结点，XGBoost可以自动学习出它的默认分裂方向。如果某个样本该特征值缺失，会将其划入默认分支。\n- **并行化**：注意不是tree维度的并行，而是特征维度的并行。XGBoost预先将每个特征按特征值排好序，存储为块结构，分裂结点时可以并行查找每个特征的最佳分割点，在极大提升训练速度。\n\n---\n\n#### XGBoost为什么使用泰勒二阶展开？\n\n- 二阶展开可以更大程度的保留原函数的信息，更加准确；\n- 二阶信息能够让梯度收敛的更快，类似牛顿法比SGD收敛更快。一阶信息描述梯度变化方向，二阶信息可以描述梯度变化方向是如何变化的；\n- 此外，这样可以允许用户自定义损失函数。\n\n---\n\n#### XGBoost为什么快？\n\n- **分块并行**：训练前每个特征按特征值进行排序并存储为Block结构，后面查找特征分割点时重复使用，并且支持并行查找每个特征的分割点；\n- **候选分位点**：每个特征采用常数个分位点作为候选分割点；\n- **CPU cache 命中优化**：不懂；\n- **Block 处理优化**：Block预先放入内存；Block按列进行解压缩；将Block划分到不同硬盘来提高吞吐\n\n---\n\n#### XGBoost中叶子结点的权重如何计算出来？\n\nXGBoost目标函数最终推导形式如下：\n\n<img src=\"XGBoost面试题总结/image-20200725003427754.png\" alt=\"image-20200725003427754\" style=\"zoom:40%;\" />\n\n利用一元二次函数求最值的知识，当目标函数达到最小值$Obj$时，每个叶子结点的权重为$w_j$。\n\n具体公式如下：\n\n<img src=\"XGBoost面试题总结/image-20200725003458316.png\" alt=\"image-20200725003458316\" style=\"zoom:50%;\" />\n\n---\n\n#### XGBoost为什么可以并行训练？\n\n- XGBoost的并行，并不是说每棵树可以并行训练，XGB本质上仍然采用boosting思想，每棵树训练前需要等前面的树训练完成才能开始训练。\n- XGBoost的并行，指的是特征维度的并行：在训练之前，每个特征按特征值对样本进行预排序，并存储为Block结构，在后面查找特征分割点时可以重复使用，而且特征已经被存储为一个个block结构，那么在寻找每个特征的最佳分割点时，可以利用多线程对每个block并行计算。\n\n---\n\n#### XGBoost防止过拟合的方法\n\n- **目标函数添加正则项**：叶子节点个数+叶子节点权重的L2正则化；\n- **列抽样**：训练的时候只用一部分特征（不考虑剩余的block块即可）；\n- **shrinkage**: 缩减单棵树带来的影响，为了给后面的训练留出更多的学习空间。\n\n---\n\n### XGBoost中如何对树进行剪枝\n\n- 在目标函数中增加了正则项：使用叶子结点的数目和叶子结点权重的L2模的平方，控制树的复杂度。\n- 在结点分裂时，定义了一个阈值，如果分裂后目标函数的增益小于该阈值，则不分裂。\n- 当引入一次分裂后，重新计算新生成的左、右两个叶子结点的样本权重和。如果任一个叶子结点的样本权重低于某一个阈值（最小样本权重和），也会放弃此次分裂。\n- XGBoost 先从顶到底建立树直到最大深度，再从底到顶反向检查是否有不满足分裂条件的结点，进行剪枝。\n\n---\n\n#### XGBoost如何处理缺失值？\n\n- 在特征k上寻找最佳 split point 时，不会对该列特征 missing 的样本进行遍历，而只对该列特征值为 non-missing 的样本上对应的特征值进行遍历，通过这个技巧来减少了为稀疏离散特征寻找 split point 的时间开销；\n- 在非叶子节点的每次分裂时，模型会学习出一个default direction，具体做法是把所有缺失值放在特征值的排序序列最左边和最右边，分别计算两种情况下的最优score，选择更优的那个split以及direction。\n\n---\n\n#### XGBoost如何选择最佳分裂点？\n\n- 对特征进行预排序，存储在block里，并propose一批百分位点当做分裂点备选；\n- 对每个特征，分别计算以第k个值作为分裂的score，选择最高的；\n\n---\n\n#### XGBoost的Scalable性如何体现？\n\n- **基分类器的scalability**：弱分类器可以支持CART决策树，也可以支持LR和Linear。\n- **目标函数的scalability**：支持自定义loss function，只需要其一阶、二阶可导。有这个特性是因为泰勒二阶展开，得到通用的目标函数形式。\n\n---\n\n#### XGBoost如何评价特征的重要性？\n\n- **weight**：该特征在所有树中被用作特征在所有树中作为划分属性的次数；\n- **gain**：该特征在其出现过的所有树中产生的平均增益。\n- **cover**：该特征在其出现过的所有树中的平均覆盖范围。覆盖范围这里指的是一个特征用作分割点后，其影响的样本数量，即有多少样本经过该特征分割到两个子节点。\n\n---\n\n#### XGBooost参数调优的一般步骤\n\n首先需要初始化一些基本变量，例如：\n\n- max_depth = 5\n- min_child_weight = 1\n- gamma = 0\n- subsample, colsample_bytree = 0.8\n- scale_pos_weight = 1\n\n1. **确定learning rate和estimator的数量**\n\n   learning rate可以先用0.1，用cv来寻找最优的estimators\n\n2. **max_depth和 min_child_weight**\n\n   我们调整这两个参数是因为，这两个参数对输出结果的影响很大。我们首先将这两个参数设置为较大的数，然后通过迭代的方式不断修正，缩小范围。\n\n   max_depth，每棵子树的最大深度，check from range(3,10,2)。\n\n   min_child_weight，子节点的权重阈值，check from range(1,6,2)。\n\n   如果一个结点分裂后，它的所有子节点的权重之和都大于该阈值，该叶子节点才可以划分。\n\n3. **gamma**\n\n   也称作最小划分损失`min_split_loss`，check from 0.1 to 0.5，指的是，对于一个叶子节点，当对它采取划分之后，损失函数的降低值的阈值。如果大于该阈值，则该叶子节点值得继续划分。如果小于该阈值，则该叶子节点不值得继续划分。\n\n4. **subsample, colsample_bytree**\n\n   subsample是对训练的采样比例\n\n   colsample_bytree是对特征的采样比例\n\n   both check from 0.6 to 0.9\n\n5. **正则化参数**\n\n   alpha 是L1正则化系数，try 1e-5, 1e-2, 0.1, 1, 100\n\n   lambda 是L2正则化系数\n\n6. **降低学习率**\n\n   降低学习率的同时增加树的数量，通常最后设置学习率为0.01~0.1\n\n---\n\n#### XGBoost模型如果过拟合了怎么解决\n\n当出现过拟合时，有两类参数可以缓解：\n\n第一类参数：用于直接控制模型的复杂度。包括`max_depth,min_child_weight,gamma` 等参数\n\n第二类参数：用于增加随机性，从而使得模型在训练时对于噪音不敏感。包括`subsample,colsample_bytree`\n\n还有就是直接减小`learning rate`，但需要同时增加`estimator` 参数。\n\n---\n\n","categories":["机器学习基础"]},{"title":"面试题整理","url":"/2020/07/16/面试题整理/","content":"\n\n## ML\n\nXGBoost如何实现并行？（腾讯实习面）\n\n介绍XGBoost（快手、京东一面）\n\nXGBoost如何处理空值？（京东一面）\n\nsoftmax函数的作用是？形式是？为什么是这个形式？（京东二面）\n\n了解logistic regression吗，介绍一下。求导之后的形式是什么？（百度一面）\n\n- [ ] **谈一下L1/L2 norm（腾讯实习面）**\n\nL1/L2 norm都是缓解模型过拟合的手段。其中：\n\nL1 norm又称LASSO，是在模型损失函数后加上了\n\n- [x] **什么是ROC/AUC，如何评估分类任务（百度一面）**\n\n**ROC**曲线的横轴是假阳性率（真实标签为negative的预测为positive的概率），纵轴是真阳性率（真实标签为positive的预测为positive的概率），当y=x时，表示无论真实标签是pos还是neg，模型预测一个样本为positive的概率都相同。可以通俗理解为，模型这时完全是在乱猜，与抛硬币本质相同，因此我们一般认为AUC的最低值为0.5。\n\n而我们希望的是真实标签为1的都能预测为1，真实标签为0的都不要预测为1，因此，如果不同模型的ROC曲线没有交叉，ROC曲线越接近左上角的模型越好。如果有交叉，可以通过AUC来评估。\n\n**AUC**指的是ROC曲线下的面积，物理含义为正例排在负例前面的概率。AUC同时考虑了分类器对正例和负例的分类能力，在样本不均衡的情况下依然可以做出合理的评价，对样本是否不平衡分布并不敏感。举例：99人没有得病，1人得病，如果全部预测为没得病，则acc为99%，但是AUC为0.5，这样就规避了不平衡带来的问题。\n\n\n\n什么是交叉熵损失函数？（百度一面）\n\n\n\nXGB有什么超参？发现训练集和测试集效果不同如何调参？（百度一面）\n\n怎么判断是过拟合还是欠拟合？（百度一面）\n\n如何解决过拟合？（百度二面）\n\nlr中log_loss和softmax的关系；\n\n\n\n## NLP\n\n介绍一下transformer\n\n为什么Transformer比seq2seq要好？（京东二面）\n\nself-attention为什么效果好？（京东二面）\n\nself-attention的表达式为什么除以根号d？（快手一面）\n\n介绍一下word embedding，什么是negative sampling？（百度一面）\n\n介绍一下TFIDF（快手一面）\n\n介绍下pre train（百度一面）\n\nBERT的输入维度是？\n\npadding对attention的影响？\n\nbert为什么mask 15%，mask标记对微调的影响是？\n\n\n\n\n\n## 数学\n\n- 如何理解矩阵的特征值与特征向量，讲一下SVD分解？（京东二面）\n\n  https://www.zybuluo.com/Perfect-Demo/note/1101229\n\n"},{"title":"XGBoost论文阅读","url":"/2020/07/12/【机器学习基础】XGBoost/","content":"\n自从陈天奇于2015年提出XGBoost以来，该模型就一直在各大数据竞赛中当作大杀器被频繁祭出。速度快、效果好是XGBoost的最大优点。XGBoost与GBDT同出一脉，都属于boosting集成学习算法，但XGBoost相较于GBDT要青出于蓝而胜于蓝。\n\n XGBoost的全称为eXtreme Gradient Boosting，[论文](https://arxiv.org/pdf/1603.02754.pdf)，本篇记录即建立在论文之上。\n\n## Review Ensemble Learning\n\n<img src=\"【机器学习基础】XGBoost/image-20200715185603736.png\" alt=\"image-20200715185603736\" style=\"zoom:50%;\" />\n\n\n\n\n\n## Tree Boosting in a Nutshell\n\n核心思想：基于残差的训练，加性模型\n\n- 每个base model都是weak learner，产生残差后，由下级weak learner拟合残差。\n\n- 即训练第二个模型的时候，$X$不变，$y$变为$(y-y_1)$，以此类推。\n\n- 最后的预测结果为每个weak learner的预测值之和。\n\n  \n\n### Regularized Learning Objective and Gradient Tree Boosting\n\n#### 目标函数\n\n<img src=\"【机器学习基础】XGBoost/image-20200715224143295.png\" alt=\"image-20200715224143295\" style=\"zoom:50%;\" />\n\n- $f_k(x_i)$ 表示模型的第 $k$ 棵树对样本 $x_i$ 的预测结果。\n- 目标函数包含了：\n  - 每个样本的损失之和：分类模型cross entropy loss，回归模型RMSE；\n  - 每棵树的惩罚：可能是对树的深度，叶节点权重，叶节点数量等的限制。\n- 正则化项的作用是防止模型的过拟合。\n\n<img src=\"【机器学习基础】XGBoost/image-20200715233401688.png\" alt=\"image-20200715233401688\" style=\"zoom:50%;\" />\n\n<img src=\"【机器学习基础】XGBoost/image-20200715234519622.png\" alt=\"image-20200715234519622\" style=\"zoom:50%;\" />\n\n注：手写体最右侧的 $Ωf(t)$ 实际应为 $Ω(f_t)$ \n\n至此，我们构造出了目标函数。\n\n\n\n#### 近似目标函数\n\n我们可以使用泰勒展开的二阶形式对目标函数做一个近似。为什么使用泰勒二阶展开，是因为它可以被用于更快的最优化目标函数。\n\n<img src=\"【机器学习基础】XGBoost/image-20200716003154915.png\" alt=\"image-20200716003154915\" style=\"zoom:50%;\" />\n\n$g_i$，$h_i$ 分别是 $f(x)$ 一阶倒数和二阶导数。\n\n这里可以这么理解：$f(x) = l(y_i, {y^{hat}_i}^{(t-1)}) $， $f(x+△x) = l(y_i, {y^{hat}_i}^{(t-1)} + f_t(x_i))$\n\n<img src=\"【机器学习基础】XGBoost/image-20200716202712717.png\" alt=\"image-20200716202712717\" style=\"zoom:50%;\" />\n\nG/h都是很容易计算的，但是 $f_t(x)$ / $Ω(f_t)$应该如何表示呢？它是一棵树，如何表示成函数的形式？\n\n\n\n#### 定义树的表达\n\n<img src=\"【机器学习基础】XGBoost/image-20200716203133182.png\" alt=\"image-20200716203133182\" style=\"zoom:50%;\" />\n\n\n\n这里 $w$，$q$是需要学习出来的，这就是对树的参数化。\n\n另外，我们再参数化树的复杂度函数。\n\n<img src=\"【机器学习基础】XGBoost/image-20200716205746249.png\" alt=\"image-20200716205746249\" style=\"zoom:50%;\" />\n\n\n\n#### 新的目标函数\n\n<img src=\"【机器学习基础】XGBoost/image-20200716213353383.png\" alt=\"image-20200716213353383\" style=\"zoom:50%;\" />\n\n从每个样本的角度到每个叶节点的角度，实质上只是对样本按照节点做了一次排列组合。\n\n至此，就转换成了对二次方的优化。\n\n<img src=\"【机器学习基础】XGBoost/image-20200716223618723.png\" alt=\"image-20200716223618723\" style=\"zoom:50%;\" />\n\n***Obj*** 函数可以用于衡量树结构 ***q(·)*** 的好坏。\n\n以上讨论均建立在树的形状已知的情况下的计算，那么如何确定树的形状呢？\n\n\n\n#### 确定最佳的树的形状\n\n一棵树可以有很多种形状的可能，每种形状都会对应一个可以计算出的obj。\n\n最佳的树的形状，对应的obj应该是所有形状对应的objs中最优的。\n\n<img src=\"【机器学习基础】XGBoost/image-20200716224028453.png\" alt=\"image-20200716224028453\" style=\"zoom:50%;\" />\n\n暴力搜索的方式显然太费时间了。\n\n回顾决策树的生长过程，以ID3为例，每次分裂都是选择可以使得信息增益最大的feature来做split，因此类比到这里，我们可以选择使得$|obj_{old} - obj_{new}|$ 值最大的feature来做split。\n\n<img src=\"【机器学习基础】XGBoost/image-20200716231239511.png\" alt=\"image-20200716231239511\" style=\"zoom:50%;\" />\n\n<img src=\"【机器学习基础】XGBoost/image-20200719134628131.png\" alt=\"image-20200719134628131\" style=\"zoom:50%;\" />\n\n当Gain>0时候，叶节点可以进行分裂。\n\n\n\n### Shrinkage and Column Subsampling\n\n除了在目标函数中加入惩罚项，作者还提出了两种防止过拟合的方式。\n\n#### Shrinkage\n\n在每一次提升树训练迭代后，在前面乘一个因子 $η$ 来收缩其权重（也就是我们说的学习率，或者叫步长）。与SGD中的学习率类似，收缩减少了每棵树的影响，并为将来的树模型留出了改进模型的空间。\n\n#### Column Subsampling\n\n这个技术用于随机森林中。根据用户反馈，使用列采样可以比传统的行采样（同样支持）更能防止过度采样。列采样还能加速稍后描述的并行算法。\n\n\n\n## Split Finding Algorithm\n\n### 精确贪心搜索\n\n精确算法要枚举所有features的所有分裂方式，这肯定会耗费很多时间。为了提高效率，算法会根据特征的值对其进行预排序，并按排好的顺序访问数据，下面是算法描述。值得注意的是，原文中，数据的维度是m而不是n，此处猜测m代表进行column sampling之后的结果，小于或等于n。\n\n<img src=\"【机器学习基础】XGBoost/image-20200721170503844.png\" alt=\"image-20200721170503844\" style=\"zoom:50%;\" />\n\n算法的思想可以总结为：\n\n- 预排序：对于某叶节点下的sample集合，依据特征k，对samples进行排序，得到m个排序后的集合（共m个特征）；\n- 分割节点：遍历第k个集合，依次把每个第j个样本都做为splitting point，计算该split下的Score；\n- 按照最高的score对该叶节点进行split。\n\n\n\n### 近似算法\n\n精确算法很精确，但是当数据量十分庞大的时候，数据无法一次性加载进内存，则搜索算法就无法执行，而且他也很耗时。于是作者提出了近似的搜索算法，该算法会：\n\n- 首先，根据特征的百分位点来预设一些candidate splitting points；\n\n- 接下来，将连续的特征值（相邻的）映射到由这些candidates分出的桶中;\n- 累加每个桶的G/H，以加和后的GH计算score，找出其中找到最优的桶；\n\n<img src=\"【机器学习基础】XGBoost/image-20200721174834509.png\" alt=\"image-20200721174834509\" style=\"zoom:50%;\" />\n\n这种分桶的方式，由于每个桶内的独立计算，允许了其并行进行，只需最后对每个并行节点的值作比较即可。\n\n> <u>举🌰说明</u>\n>\n> <img src=\"【机器学习基础】XGBoost/XGBoost-Detail-Analysis5.png\" alt=\"XGBoostDetailAnalysis5\" style=\"zoom:120%;\" />\n>\n> $$ Gain = max\\{ Gain, \\frac{G_1^2}{H_1 + \\lambda} + \\frac{G_{23}^2}{H_{23} + \\lambda} - \\frac{G_{123}^2}{H_{123} + \\lambda} - \\gamma,\\; \\frac{G_{12}^2}{H_{12} + \\lambda} + \\frac{G_3^2}{H_3 + \\lambda} - \\frac{G_{123}^2}{H_{123} + \\lambda} - \\gamma\\} $$\n\n\n\n分桶有两种模式：\n\n- 全局模式：在算法开始时，对每个维度分桶一次，后续的分裂都依赖于该分桶并不再更新。\n  - 优点是：只需要计算一次，不需要重复计算。\n  - 缺点是：在经过多次分裂之后，叶结点的样本有可能在很多全局桶中是空的。\n- 局部模式：除了在算法开始时进行分桶，每次拆分之后再重新分桶。\n  - 优点是：每次分桶都能保证各桶中的样本数量都是均匀的。\n  - 缺点是：计算量较大。\n\n为了不让空桶出现，全局模式会构造更多的候选拆分点。而局部模式会更适合构建更深的树。\n\n\n\n### 加权分桶\n\n实际上 XGBoost 不是简单按照样本值进行分位， 而是以二阶导数值作为权重的样本值来分。\n\n假设每个sample的第k维特征，及候选样本的损失函数的二阶偏导数为：$D_k={(x_{1k},h_1),(x_{2k},h_2)⋯(x_{nk},h_n)}$。\n\n定义rank function，\n\n$$ r_k(z) = \\frac{\\sum_{(x, h)\\in D_k,\\ x<z}{h}}{\\sum_{(x, h)\\in D_k}{h}} $$\n\nrank函数可以反应所有第k维特征取值小于z的样本的二阶梯度之和占所有的比例。\n\n我们的目标是找到一个候选的分割节点集 $ {(x_{1k},h_1),(x_{2k},h_2)⋯(x_{nk},h_n)} $，这个集合满足\n\n$$|r_k(s_k, j) - r_k(s_k, j+1)| < \\delta,\\ s_{k1} = \\mathop{min} \\limits_i \\ x_{ik},\\ s_{kl} = \\mathop{max}\\limits_i\\ x_{ik}$$，\n\n其中$x_{i, k}$表示样本i的第k个特征。即：\n\n- 最小的拆分点是所有样本第k维的最小值。\n- 最大的拆分点是所有样本第k维的最大值。\n- 中间的拆分点：选取拆分点，使得相邻拆分点的rank函数值小于 $\\delta$。\n  - 其意义为：第 k维大于等于$s_{k, j}$，小于$s_{k, j+1}$  的样本的h之和，占总的 h之和的比例小于$\\delta$  。\n  - 这种拆分点使得每个桶内的以h为权重的样本数量比较均匀，而不是样本个数比较均匀。\n\n使用h来赋予样本的权重，是因为损失函数可以改写为\n\n<img src=\"【机器学习基础】XGBoost/image-20200722082120815.png\" alt=\"image-20200722082120815\" style=\"zoom:35%;\" />\n\n这可以被看成是关于树函数的是权重为$h_i$ 的加权平方损失函数。\n\n\n\n### Sparsity-aware Split Finding\n\n在实际问题中，稀疏数据是十分常见的，造成数据稀疏的原因一般可以归咎为数据缺失，某个特征出现较多的0值，one hot编码引入的大量0。为了应对缺失值问题，作者提出了一种处理方式：为每个树节点增加一个默认的方向，当x中的相应特征值缺失时，x就被分到这个default方向上。即对于稀疏特征，只需要对有效值进行处理，无效值则采用默认的分裂方向（要么是左，要么是右）。\n\n此外，鉴于0值的特殊性，在XGBoost 算法的实现中，允许对数值0进行不同的处理。可以将数值0视作缺失值，也可以将其视作有效值。\n\n那么如何指定这个默认的方向呢？答案是由模型学习出来。算法如下：\n\n<img src=\"【机器学习基础】XGBoost/image-20200722231753787.png\" alt=\"image-20200722231753787\" style=\"zoom:50%;\" />\n\n可以总结为：首先让所有缺失值都在右子树上，计算出gain，然后让所有缺失值都在左子树上，计算出gain，选取出最大对的gain，即对应着最优的样本划分。\n\n\n\n## 系统设计\n\n### Column Block\n\n算法中最耗时的部分就是预排序，为了节省排序的时间，XGBoost将数据存在内存单元block中，同时在block采用CSC 格式存放(Compressed Column format)，每一列（即每个属性的取值）均升序存放，这样，一次读入数据并排好序后，以后均可使用。在精确贪心算法中，将所有数据均导入内存，算法只要在数据中线性扫描已经预排序过的特征就可以。对于近似算法，可以用多个block(Multiple blocks)分别存储不同的子样本集，多个block可以并行计算。\n\n重要的是，由于将数据按列存储，可以同时访问所有列，那么可以对所有属性同时执行split finding算法，从而并行化split finding.\n\n### Cache-aware Access\n\n略\n\n### Out of Core\n\n略","categories":["机器学习基础"]},{"title":"【CS224N】L8. NMT, seq2seq, attention","url":"/2020/06/20/【CS224N】L8. NMT, seq2seq, attention/","content":"\n# 【CS224N】L8. NMT, seq2seq, Attention\n\n这节课将会：\n\n- 介绍一个新任务：Machine Translation\n- 介绍一个新神经网络架构：sequence to sequence\n- 介绍一个新的神经网络技术：Attention\n\n## Statistical Machine Translation\n\n大都是Rule-based，即有一个对照表dictionary。这里我们只简单介绍，不是重点。\n<img src=\"【CS224N】L8. NMT, seq2seq, attention/image-20200620151945250.png\" alt=\"image-20200620151945250\" style=\"zoom:50%;\" />\n\n<img src=\"【CS224N】L8. NMT, seq2seq, attention/image-20200620152018340.png\" alt=\"image-20200620152018340\" style=\"zoom:50%;\" />\n\n这里a是一个对照的基准，用于映射英语与法语之间词、短语级别的对应关系，又可以分为1对1，多对1，1对多，多对多，十分复杂！\n\n## Neural Machine Translation\n\n### Basic Ideas of NMT and seq2seq\n\nNMT的概念最早提出时，同时也带来了seq2seq model。\n\n下面是seq2seq在做预测时候的示意图。encoder对输入的句子进行编码，编码的结果作为decoder hidden states的初始值，decoder每个t时刻预测出来的结果，当做t+1时刻的inputs，t时刻的hidden state会传递给t+1时刻的hidden layer。\n\n<img src=\"【CS224N】L8. NMT, seq2seq, attention/image-20200620153218480.png\" alt=\"image-20200620153218480\" style=\"zoom:50%;\" />\n\nNMT可以被视为一个条件语言模型。\n\n<img src=\"【CS224N】L8. NMT, seq2seq, attention/image-20200620153918406.png\" alt=\"image-20200620153918406\" style=\"zoom:50%;\" />\n\n### Training NMT\n\nseq2seq的训练过程与预测过程有所不同。训练过程的decoder每一步的输入是groud truth在该timestamp的真实输入，而预测过程是用t-1的预测词来预测t的词。\n\n<img src=\"【CS224N】L8. NMT, seq2seq, attention/image-20200620154903428.png\" alt=\"image-20200620154903428\" style=\"zoom:50%;\" />\n\n### Decoding Methods\n\n#### Greedy decoding\n\n到目前，我们在解码的时候采用的思路都是：在每一个时间戳做预测的时候都预测当前最优解，但是这样最终结果不一定是全局最优的。这种方法叫做贪心解码，即greedy decoding。\n\n#### Exhaustive search decoding\n\nExhaustive search decoding意为在每一个timestamp都遍历所有可能的结果，即$|V|$，这样一定可以选择出全局最优解。但是这样的时间复杂度很高，为$O(|V|^T)$。\n\n#### Beam Search Decoding\n\n<img src=\"【CS224N】L8. NMT, seq2seq, attention/image-20200621002943340.png\" alt=\"image-20200621002943340\" style=\"zoom:50%;\" />\n\n核心思想：在解码的每一个时间戳的每个分支上，都生成K个candidates，对比当前的所有path，选择K个score最高的，继续解码。下面是Beam search的process。\n\n<img src=\"【CS224N】L8. NMT, seq2seq, attention/image-20200621003718158.png\" alt=\"image-20200621003718158\" style=\"zoom: 90%;\" />\n\n<img src=\"【CS224N】L8. NMT, seq2seq, attention/image-20200621004505085.png\" alt=\"image-20200621004505085\" style=\"zoom: 90%;\" />\n\n<img src=\"【CS224N】L8. NMT, seq2seq, attention/image-20200621010214561.png\" alt=\"image-20200621010214561\" style=\"zoom:50%;\" />\n\nBeam search什么时候搜索结束呢？\n\n<img src=\"【CS224N】L8. NMT, seq2seq, attention/image-20200621010344131.png\" alt=\"image-20200621010344131\" style=\"zoom:50%;\" />\n\n既然可能会出现提前停止的分支，我们知道短的分支直觉上是会比长的分支score高的，因为长度+1，score会加上一个负数。面对这种情况，我们可以对其正则化。\n\n<img src=\"【CS224N】L8. NMT, seq2seq, attention/image-20200621010620916.png\" alt=\"image-20200621010620916\" style=\"zoom:35%;\" />\n\n#### BLEU\n\n<img src=\"【CS224N】L8. NMT, seq2seq, attention/image-20200621010949683.png\" alt=\"image-20200621010949683\" style=\"zoom:50%;\" />\n\nBLEU的计算方式如下如所示：\n\n首先令 k 是我们要评估的分数的最大 n-gram。即如果 k=4，BELU分数仅计算大小 == 4 的 n-grams ，并忽略大于4的 n-grams 。\n\n对长度是 n 的 grams 的精确度分数：\n\n$$p_n =  count(matched\\ n-grams)\\ /\\ count(n-grams\\ in\\ candidate\\ translation)$$。\n\n最后，令 $w_{n}=1 / 2^{n}$ 是第 n 个 gram 的几何加权。我们简单惩罚的定义为：\n\n$$\\beta=e^{\\min \\left(0,1-\\frac{len_{ref}}{len_{MT}}\\right)}$$\n\n其中 $len_{ref}$ 是参考翻译的句子长度， $len_{MT}$ 是机器翻译的句子长度。\n\n至此，BELU 分数定义为：$$ BELU=\\beta \\prod_{i=1}^{k} p_{n}^{w_{n}} $$.\n\n关于BLEU，再贴上知乎er的理解。\n\n> **BLEU 的大意是比较候选译文和参考译文里的 n-gram（实践中从 unigram 取到 4-gram） 重合程度，重合程度越高就认为译文质量越高。选不同长度的 n-gram 是因为，unigram 的准确率可以用于衡量单词翻译的准确性，更高阶的 n-gram 的准确率可以用来衡量句子的流畅性。**\n>\n> 这是一个**只看中准确率**的指标，就是说更加关心候选译文里的多少 n-gram 是对的（即在参考译文里出现了），而不在乎召回率（参考译文里有哪些 n-gram 在候选译文中没出现）。不过这不算特别严重的问题，因为 BLEU 原论文**建议大家的测试集里给每个句子配备 4 条参考译文**，这样就可以减小语言多样性带来的影响（然而现在很多机器翻译的测试集都是只有 1 条译文，尴尬= =）；另外还有 brevity penalty 来惩罚候选译文过短的情况（候选译文过短在机器翻译中往往意味着漏翻，也就是低召回率）。\n>\n> 作者：Towser\n> 链接：https://www.zhihu.com/question/304798594/answer/567383628\n> 来源：知乎\n> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n## Attention\n\n### Basic Ideas\n\n我们知道，在RNNs encoder里，所有timestamp的信息都堆积在最后一个unit里，这样很容易引起信息存储的瓶颈，严重影响model的效果，为此我们之前讨论了多种解决方案，包括LSTM/GRU/residual net等。\n\n<img src=\"【CS224N】L8. NMT, seq2seq, attention/image-20200621020606588.png\" alt=\"image-20200621020606588\" style=\"zoom:50%;\" />\n\nAttention机制也可以很好地解决这个问题。\n\nAttention的核心思想：在decoder阶段的每个timestamp都用一个直接与encoder的连接，通过计算“重要性”，来关注一些特定的source sequence。\n\n下面是seq2seq with attention的示意图。\n\n<img src=\"【CS224N】L8. NMT, seq2seq, attention/image-20200621021230667.png\" alt=\"image-20200621021230667\" style=\"zoom:50%;\" />\n\n<start>的hidden state与encoder每个词的hidden state计算attention score，这里的计算方式常见为dot product。经过softmax归一化，可以得到<start>与每个输入token的注意力分布。\n\n<img src=\"【CS224N】L8. NMT, seq2seq, attention/image-20200621021541512.png\" alt=\"image-20200621021541512\" style=\"zoom:50%;\" />\n\n\n\n<img src=\"【CS224N】L8. NMT, seq2seq, attention/image-20200621021620299.png\" alt=\"image-20200621021620299\" style=\"zoom:50%;\" />\n\n接下来在进行第二个词的预测，与RNN一样，是把t-1时刻的输出当做t时刻的输入，以此类推，直至<END>。\n\n<img src=\"【CS224N】L8. NMT, seq2seq, attention/image-20200621022037839.png\" alt=\"image-20200621022037839\" style=\"zoom:50%;\" />\n\n接下来是上面过程中涉及到的数学表达式。\n\n<img src=\"【CS224N】L8. NMT, seq2seq, attention/image-20200621022227921.png\" alt=\"image-20200621022227921\" style=\"zoom:50%;\" />\n\n### Advantages of Attention\n\n1. 解决了rnn的bottleneck problem；\n2. 解决了梯度消失；\n3. 更具有可解释性：通过可视化attention distribution，可以看到decoder的每个词与encoder每个词的相互关系。\n\n### General Attention\n\nAttention可以被用在很多任务，很多架构中。\n\n<img src=\"【CS224N】L8. NMT, seq2seq, attention/image-20200621022647674.png\" alt=\"image-20200621022647674\" style=\"zoom:50%;\" />\n\n<img src=\"【CS224N】L8. NMT, seq2seq, attention/image-20200621022737933.png\" alt=\"image-20200621022737933\" style=\"zoom:50%;\" />\n\n### Several Attention Variants\n\nAttention的变体方式通常是以下几种：\n\n1. 针对计算attention score的方式；\n\n   <img src=\"【CS224N】L8. NMT, seq2seq, attention/image-20200621023050746.png\" alt=\"image-20200621023050746\" style=\"zoom:50%;\" />\n\n2. 针对获得attention distribution的方式；\n\n3. 针对通过weighted sum获取attention output的方式。\n\n\n\n## 后记\n\n整理完这一篇已经三点了。。还是节奏很慢，希望明天有时间看完Transformer。","tags":["CS224N"],"categories":["NLP"]},{"title":"【CS224N】L6/L7. LM, RNN/LSTM/GRU","url":"/2020/06/17/【CS224N】L6_L7. LM, RNN_LSTM_GRU/","content":"\n# 【CS224N】L6_L7. LM, RNN_LSTM_GRU\nL6和L7从Language model出发，讲解了NLP中非常常见的RNN以及各种variants。主要包含以下内容：\n\n- Language model\n- RNN\n- Gradient vanishing/exploding\n- LSTM\n- GRU\n- Bidirectional RNN\n- Deep RNN\n\n## N-gram Language Models\n\n语言模型是NLP中的一类任务，它的目的是预测接下来的词将会是什么，即给定前n词，计算出第n+1个词的概率分布。语言模型的应用比较广泛，比如拼音输入法的智能提示，智能纠错等。\n\n<img src=\"【CS224N】L6_L7. LM, RNN_LSTM_GRU/image-20200616235905326.png\" alt=\"image-20200616235905326\" style=\"zoom:50%;\" />\n\n<img src=\"【CS224N】L6_L7. LM, RNN_LSTM_GRU/image-20200616235519607.png\" alt=\"image-20200616235519607\" style=\"zoom:50%;\" />\n\n\n\n在deep learning之前，statistical NLP中有n-gram LM。\n\n<img src=\"【CS224N】L6_L7. LM, RNN_LSTM_GRU/image-20200617000941455.png\" alt=\"image-20200617000941455\" style=\"zoom:50%;\" />\n\n接下来是一个具体的4gram LM的例子。\n\n<img src=\"【CS224N】L6_L7. LM, RNN_LSTM_GRU/image-20200617001233748.png\" alt=\"image-20200617001233748\" style=\"zoom:50%;\" />\n\n可以看出，4gram无法看到前面语句中的keywords，丢弃太多句子成分，预测只看语料库的概率分布。\n\n除此之外，n-gram LM还有其他问题。\n\n第一个是稀疏性。表现在：\n\n1. 正确的n-gram在训练语料中从未出现过\n\n   解决方案：为每个 w∈V 添加极小数 δ 。这叫做平滑。这使得词表中的每个单词都至少有很小的概率。\n\n2. (N-1) gram在训练预料中从未出现过\n\n   解决方案：后退。即(N-1)gram变为(N-2)gram。\n\n<img src=\"【CS224N】L6_L7. LM, RNN_LSTM_GRU/image-20200617001428764.png\" alt=\"image-20200617001428764\" style=\"zoom:50%;\" />\n\n第二个是存储问题。存储所有的n-gram显然会造成大量的空间消耗。\n\n<img src=\"【CS224N】L6_L7. LM, RNN_LSTM_GRU/image-20200617233404296.png\" alt=\"image-20200617233404296\" style=\"zoom:50%;\" />\n\n至此为statistical LM，接下来即为neural LM。\n\n\n\n## NNLM\n\n基于前馈神经网络的语言模型是对统计语言模型N-gram的实现。\n\n<img src=\"【CS224N】L6_L7. LM, RNN_LSTM_GRU/image-20200802160236396.png\" alt=\"image-20200802160236396\" style=\"zoom:50%;\" />\n\n简单地由三层构成，即输入层，隐藏层，输出层。输入层为第t个词之前的n-1个词，共同构成N-gram，在隐藏层对他们进行拼接。隐藏层激活函数为tanh，然后输出层用softmax输出。\n\n改进方向：\n\n- 只对一部分输出进行梯度传播，如了呢的这种infomation比较少的词汇；\n\n- 引入先验知识，如词性；\n\n- 解决一词多义问题；\n\n- 加速softmax层的计算。softmax层的维度是 $|V|$，即词表大小（1w以上），计算会十分缓慢。\n\n  - 层次softmax；\n  - 负采样；\n\n  \n\n## RNNLM\n\n**Unlike n-gram which only focus on nearby words, Recurrent Neural Networks (RNN) are capable of conditioning the model on all previous words in the corpus.**\n\n### RNN model\n\nRNN核心思想是：用了同一个参数矩阵W ($W_h, W_e$都不变)在各个时间上共享，共同训练，经过最后一个时间步计算加上反向传播后得到的W，会在infer过程的各层中共享。\n\n<u>***值得注意的是，在各个深度学习框架里，对RNN的实现有区别。Keras采用padding的方式，对批量句子进行按最长句子长度补全长度，Pytorch则是dynamic的方式***</u>\n\n<img src=\"【CS224N】L6_L7. LM, RNN_LSTM_GRU/image-20200618202714992.png\" alt=\"image-20200618202714992\" style=\"zoom:50%;\" />\n\n下面是RNN的例子。\n\n$x$是输入的词或者词的index，经过E后得到其word embedding $e^n$，作为模型每一个时间戳$t$的输入。其后该输入（乘上一个参数$W_e$）、时间$t-1$的隐藏层输出（乘上参数$W_h$）一起，构成时间t的隐藏层输入，作用一个非线性的激活函数，如$tanh$，即可得到时间$t$的隐藏层输出。\n\n<img src=\"【CS224N】L6_L7. LM, RNN_LSTM_GRU/image-20200618203119586.png\" alt=\"image-20200618203119586\" style=\"zoom:50%;\" />\n\n**RNN 的优点**\n\n- 可以处理任意长度的输入（并不）；\n- 在时间t的计算会用到很长时间之前的信息；\n- 模型的大小不随着输入长度的增加而变大；\n\n**RNN的缺点**\n\n- 循环的计算实际上很慢，顺序的计算无法并行化；\n\n- 在实际应用中，很难catch到比较久之前的信息。\n\n\n\n### 损失函数\n\nRNN的损失函数一般是交叉熵损失函数（cross entropy loss）。\n\n<u>？？？</u>\n\n<img src=\"【CS224N】L6_L7. LM, RNN_LSTM_GRU/image-20200618212812170.png\" alt=\"image-20200618212812170\" style=\"zoom:45%;\" />\n\n因此对于一个长度为T的输入，整体的损失函数即为：\n\n<img src=\"【CS224N】L6_L7. LM, RNN_LSTM_GRU/image-20200618212929299.png\" alt=\"image-20200618212929299\" style=\"zoom:40%;\" />\n\n### Evaluation on LM\n\n语言困惑度 $PP(·)$ \n\n<img src=\"【CS224N】L6_L7. LM, RNN_LSTM_GRU/image-20200618222820124.png\" alt=\"image-20200618222820124\" style=\"zoom:50%;\" />\n\n\n\n即如果对其取自然对数，我们可以得到如下关系: $P(S)\\ = \\ e^L$。 因此在计算loss的时候，就可以顺手计算出来困惑度的值，但是需要注意，由于大部分情况下我们会使用batch来训练，这样就会有padding，因此计算困惑度的时候要去掉padding。\n\n\n\n### 反向传播，梯度弥散，梯度爆炸\n\n这张slide展示的是一个general RNN。在基本结构的基础上添加了target sequence $y^t$，与$o^t$计算CELoss，得到$L^t$。\n\n对L的求梯度过程：L对o求梯度，o对h求梯度，递归地进行 {h对之前的h求梯度，之前的h对W求梯度}。\n\n<img src=\"【CS224N】L6_L7. LM, RNN_LSTM_GRU/image-20200618233214485.png\" alt=\"image-20200618233214485\" style=\"zoom:50%;\" />\n\n这里就引出了梯度爆炸和梯度弥散的问题。\n\n<img src=\"【CS224N】L6_L7. LM, RNN_LSTM_GRU/image-20200618233430772.png\" alt=\"image-20200618233430772\" style=\"zoom:50%;\" />\n\n接下来是对梯度弥散和梯度爆炸的数学解释。\n\n<img src=\"【CS224N】L6_L7. LM, RNN_LSTM_GRU/image-20200618234335751.png\" alt=\"image-20200618234335751\" style=\"zoom:50%;\" />\n\n为什么梯度弥散会在RNN中是一个问题呢？\n\n1. 远处的梯度消失了，会导致模型权重的更新只依赖于近处的影响；\n\n2. 梯度可以被认为是一种过去对现在影响力的衡量标准。如果经过长距离的传播后，梯度变得很小，那么我们无法分辨是因为我们的参数设计的不对，还是因为两者之间确实没有什么依赖性。\n\n#### 梯度爆炸的解决方式：梯度裁剪\n\n梯度裁剪被用于解决梯度爆炸问题。\n\n<img src=\"【CS224N】L6_L7. LM, RNN_LSTM_GRU/image-20200619005143152.png\" alt=\"image-20200619005143152\" style=\"zoom:50%;\" />\n\n#### 梯度弥散的解决方式\n\n1. 残差连接\n\n   <img src=\"【CS224N】L6_L7. LM, RNN_LSTM_GRU/image-20200619005450432.png\" alt=\"image-20200619005450432\" style=\"zoom:50%;\" />\n\n2. 密集连接\n\n   <img src=\"【CS224N】L6_L7. LM, RNN_LSTM_GRU/image-20200619005519866.png\" alt=\"image-20200619005519866\" style=\"zoom:50%;\" />\n\n3. RNN的变体\n\n   GRU and LSTM.\n\n## LSTM\n\n选择性记住，选择性忘记，这就是LSTM。\n\n<img src=\"【CS224N】L6_L7. LM, RNN_LSTM_GRU/image-20200619220712817.png\" alt=\"image-20200619220712817\" style=\"zoom:50%;\" />\n\n<img src=\"【CS224N】L6_L7. LM, RNN_LSTM_GRU/image-20200619224010692.png\" alt=\"image-20200619224010692\" style=\"zoom:50%;\" />\n\n\n\nLSTM的结构使得RNN可以更容易的保存住很久之前的信息，因为有forget gate来选择哪些信息留下，哪些舍弃。但是LSTM**<u>无法根本性解决</u>**梯度弥散问题。\n\n## GRU\n\nGRU，全称为Gated Recurrent Units。GRU可以视为对LSTM的简化。LSTM可以是一个默认使用的model，但是如果想让训练更快，那么可以用GRU代替。数据集大的时候用LSTM，数据集小的时候用GRU。\n\n<img src=\"【CS224N】L6_L7. LM, RNN_LSTM_GRU/image-20200619222102753.png\" alt=\"image-20200619222102753\" style=\"zoom:50%;\" />\n\n<img src=\"【CS224N】L6_L7. LM, RNN_LSTM_GRU/image-20200619223807308.png\" alt=\"image-20200619223807308\" style=\"zoom:50%;\" />\n\n## bidirectional RNN\n\n在情感分类任务中，后面出现的词可能会对前面出现的词的情绪造成影响。例如：the movie was terribly exciting. terribly可能会是一个消极的信号，但是结合后面的exciting，就是积极的。\n\n<img src=\"【CS224N】L6_L7. LM, RNN_LSTM_GRU/image-20200619230406503.png\" alt=\"image-20200619230406503\" style=\"zoom:50%;\" />\n\n此时可以使用bidirectional RNN来解决。bidirectional RNN中，正向和反向的hidden state会被concatenate在一起。\n\n<img src=\"【CS224N】L6_L7. LM, RNN_LSTM_GRU/image-20200619230708537.png\" alt=\"image-20200619230708537\" style=\"zoom:50%;\" />\n\nbidirectional RNN只有在句子整体都可以被访问到的情况下才适用，不适合生成模型。bidirectional RNN是十分强大的，如果可以获取整个的输入句子，那么应该默认使用bidirectional RNN。BERT就是bidirectional的architecture。\n\n## Multi-layer RNNs\n\ndeep RNN可以处理更为复杂的输入，其中lower RNNs 计算 lower-level features，higher RNNs 计算 higher-level features。下面是deep RNN的示意图。\n\n<img src=\"【CS224N】L6_L7. LM, RNN_LSTM_GRU/image-20200619231318989.png\" alt=\"image-20200619231318989\" style=\"zoom:50%;\" />\n\n高性能的RNN一般都是deep的，但是又不像DNN/CNN那样deep。\n\n例如，对于NMT来说，encoder RNN用2-4层，decoder RNN用4层。\n\n## Reference\n\n- [详解深度学习中的梯度消失、爆炸原因及其解决方法](https://zhuanlan.zhihu.com/p/33006526) \n\n\n\n\n\n***<u>后记：这两节课的学习和总结用了一周的时间，节奏还是比较慢的。</u>***","tags":["CS224N"],"categories":["NLP"]},{"title":"集成学习","url":"/2020/06/11/集成学习/","content":"# 【ML】集成学习\n\n1. 集成学习`ensemble learning`是通过构建并结合多个学习器来完成学习任务。其一般结构为：\n\n   - 先产生一组“个体学习器”（`individual learner`) 。个体学习器通常由一种或者多种现有的学习算法从训练数据中产生。\n\n     - 如果个体学习器都是从某一种学习算法从训练数据中产生，则称这样的集成学习是同质的`homogenerous`。\n\n       此时的个体学习器也称作基学习器`base learner`，相应的学习算法称作基学习算法。\n\n     - 如果个体学习器是从某几种学习算法从训练数据中产生，则称这样的集成学习是异质的`heterogenous` 。\n\n   - 再使用某种策略将它们结合起来。集成学习通过将多个学习器进行组合，通常可以获得比单一学习器显著优越的泛化性能。\n\n2. 通常选取个体学习器的准则是：\n\n   - 个体学习器要有一定的准确性，预测能力不能太差。\n   - 个体学习器之间要有多样性，即学习器之间要有差异。\n\n3. 通常基于实际考虑，往往使用预测能力较强的个体学习器（即强学习器，与之对应的为弱学习器）。\n\n   强学习器的一个显著的好处就是可以使用较少数量的个体学习器来集成就可以获得很好的效果。\n\n4. 根据个体学习器的生成方式，目前的集成学习方法大概可以分作两类：\n\n   - 个体学习器之间存在强依赖关系、必须串行生成的序列化方法，每一轮迭代产生一个个体学习器。其中以`Boosting`为代表。\n   - 个体学习器之间不存在强依赖关系、可同时生成的并行化方法。其中以`Bagging`和随机森林`Random Forest`为代表。\n\n\n\n"},{"title":"【机器学习基础】 Lasso & Ridge regression, 正则化","url":"/2020/05/05/【机器学习基础】Lasso & Ridge regression/","content":"\n\nSlides的内容来自HKUST的Prof. Nevin L. ZHANG.\n\n<img src=\"【机器学习基础】Lasso & Ridge regression/1.png\" style=\"zoom:50%;\" />\n\n<img src=\"【机器学习基础】Lasso & Ridge regression/3.png\" style=\"zoom:50%;\" />\n\n<img src=\"【机器学习基础】Lasso & Ridge regression/2.png\" style=\"zoom:50%;\" />\n\n\n\n## Note\n\n- 这两个都是正则化的手段。LASSO是基于回归系数的一范数，Ridge是基于回归系数的二范数的平方;\n\n- 根据Hastie, Tibshirani, Friedman的经典教材，如果模型中有很多变量对模型都有些许影响，那么用Ridge；如果你的模型中只有少量变量对模型很大影响，那么用LASSO。LASSO可以使得很多变量的系数为0（相当于降维），特征选择，可以简化模型；而Ridge不会进行特征选择;\n- 因为Ridge计算起来更快，所以当数据量特别大的时候，更倾向于用Ridge;\n- 最万能的方法是用LASSO和Ridge都试一试，比较两者Cross Validation的结果;\n- 最后补充一下，你也可以尝试一下两者的混合，Elastic Net。","categories":["机器学习基础"]},{"title":"Linux常用指令速查","url":"/2020/05/03/linux指令/","content":"\n### awk\n\n```bash\nawk '{print $0}' file    #打印所有列\nawk '{print $1}' file  #打印第一列\nawk '{print $1, $3}' file   #打印第一和第三列\ncat file | awk '{print $3, $1}'   #打印第三列和第一列，注意先后顺序。\ncat file | awk '{print $3, $NF}' #打印第三列和最后一列\nawk -F \":\" '{print $1, $3}'  #以“:”为分隔符分割列，然后打印第一列和第三列\nawk '{for(i=13;i<=NF;i++) printf $i\" \";printf \"\\n\"}' file #打印第13列之后的所有\n```\n\n\n\n### paste\n\npaste会把每个文件以列对列的方式，一列列地加以合并。\n\n```bash\n文件： pas1\nID897\nID666\nID982\n文件： pg pas2\nP.Jones\nS.Round\nL.Clip\n\n1. 基本paste命令将pas1和pas2两文件粘贴成两列：\n    > paste pas1 pas2\n    ID897   P.Jones\n    ID666   S.Round\n    ID982   L.Clip\n2. 通过交换文件名即可指定哪一列先粘：\n    > paste pas2 pas1\n    P.Jones ID897\n    S.Round ID666\n    L.Clip ID982\n3. 要创建不同于空格或tab键的域分隔符，使用-d选项。下面的例子用冒号做域分隔符。\n    > paste -d: pas2 pas1\n    P.Jones:ID897\n    S.Round:ID666\n    L.Clip:ID982\n4. 要合并两行，而不是按行粘贴，可以使用-s选项。下面的例子中，第一行粘贴为ID号，第二行是名字。\n    > paste -s pas1 pas2\n    ID897   ID666   ID982\n    P.Jones S.Round L.Clip\n```","tags":["Linux"],"categories":["Linux"]},{"title":"【机器学习基础】GBDT","url":"/2020/03/24/【机器学习基础】GBDT/","content":"\n### 概述\n\nGBDT全称为Gradient Boosting Decison Tree，是boosting家族的一员，其弱学习器限定只能用CART回归树模型。在GBDT的迭代中，假设我们前一轮迭代得到的强学习器是$f_{𝑡−1}(𝑥)$, 损失函数是$𝐿(𝑦,𝑓_{𝑡−1}(𝑥))$，我们本轮迭代的目标是找到一个CART回归树模型的弱学习器$ℎ_𝑡(𝑥)$，最小化本轮的损失函数$$ L(y,f_t(x)=L(y, f_{t−1}(x)+h_t(x))$$也就是说，本轮迭代找到决策树，要让样本的损失尽量变得更小。\n\nGBDT的思想可以用一个通俗的例子解释，假如有个人30岁，我们首先用20岁去拟合，发现损失有10岁，这时我们用6岁去拟合剩下的损失，发现差距还有4岁，第三轮我们用3岁拟合剩下的差距，差距就只有一岁了。如果我们的迭代轮数还没有完，可以继续迭代下面，每一轮迭代，拟合的岁数误差都会减小。最终把每棵树的结论加起来，本例中即为 20+6+3+1 = 30。实际工程中，GBDT是计算负梯度，用负梯度近似残差。\n\n### GBDT的负梯度拟合\n\n提升树中，当损失函数是平方损失函数和指数损失函数时，每一步优化都很简单。因为平方损失函数和指数损失函数的求导非常简单。当损失函数是一般函数时，往往每一步优化不是很容易。针对这个问题，`Freidman`提出了梯度提升算法：用损失函数的负梯度来拟合本轮损失的近似值，进而拟合一个CART回归树。\n\n<img src=\"image-20200727203716005.png\" alt=\"image-20200727203716005\" style=\"zoom:55%;\" />\n\n","categories":["机器学习基础"]},{"title":"【机器学习基础】决策树","url":"/2020/03/17/【机器学习基础】决策树/","content":"\n\n\n### 基本概念\n\n1. 决策树是极其接近人类思维的一种机器学习算法，没有包含很复杂的数学模型。其本质是从训练数据集中归纳出一条分类规则；\n\n2. 决策树的判别过程可以视作 IF-THEN 模型，即：根据样本某个特征的取值，不断地判别下去，对数据集做划分，直至归类成功；IF-THEN 是互斥且完备的，即：每一个样本点都被一条且仅被一条决策的路径所覆盖；\n3. 决策树是树型结构，其根节点为全部样本点的集合，中间结点表示某一个特征或者属性，叶子结点表示某一个类；\n\n4. 决策树学习通常包括三个步骤：特征选择、决策树生成以及决策树的剪枝。\n\n\n\n### 特征选择\n\n既然决策树只是在不停地做 IF-THEN，那么问题就出现了：一个样本有n个属性的话，如何选择属性的优先性呢？\n\n**我们通常根据信息增益或者信息增益比来做特征选择，选择数值更大的属性作为划分依据。**\n\n那么什么是信息增益/信息增益比？这里，我们来了解以下概念。\n\n#### Concept_1 信息熵\n\n1. 直观理解：熵描述了（系统/随机变量的）不确定性。熵越大，不确定性越大，信息含量越少。\n2. 公式： $$H(X)=-\\sum_{i=1}^{n}p_{i}log_{2}p_{i}$$\n\n3. 熵仅依赖X的分布，与X的取值无关，因此又可以记作：$H(p)=-\\sum_{i=1}^{n}p_{i}log_{2}p_{i}$\n\n#### Concept_2 条件熵\n\n1. $H(Y|X)$ 定义为：在X给定条件下，Y的条件概率分布的熵 对X的数学期望；\n\n2. 公式：$$H(Y|X)=\\sum_{i=1}^{n}p_{i}H(Y|X=x_{i})$$\n\n信息熵里的 $p_{i}$ 的计算是根据 当前样本集的分类情况，依据概率分布来计算。\n而条件熵里的 $p_{i}$ 的计算是根据 当前样本集按照某个属性划分后，每一个划分占总体的比例来计算\n举栗请看《统计学习方法》P62 例5.2 \n\n#### Concept_3 信息增益\n\n特征A对数据集D的信息增益$g(D, A)$定义为：集合D的熵$H(D)$与特征A给定条件下D的经验熵$H(D|A)$之差，\n\n即：$$g(D, A)=H(D)-H(D|A)$$\n\n信息增益的符号，在有些地方也用gain()表示。\n\n#### Concept_4 信息增益比\n\n特征A对数据集D的信息增益比$g_{R}\\left ( D, A\\right )$定义为：\n\n信息增益$g(D, A)$与训练集D关于特征A的值的熵$H_{A}(D)$的比值. 即：$$g_{R}\\left ( D, A\\right )= \\frac{g\\left ( D, A \\right )}{H_{A}(D)}$$\n\n其中，$$H_{A}(D)=-\\sum_{i=1}^{n}\\frac{D_{i}}{D}log_{2}\\frac{D_{i}}{D}$$\n\n$D_{i}$ 是根据属性A划分出的第i个子集.\n\n\n\n### 决策树生成\n\n本节包含ID3、C4.5和CART算法，CART放在[CART决策树](#cartdt)部分学习。\n\n#### ID3算法\n\nID3算法就是在决策树的各个节点上应用信息增益来选择特征，递归的构建决策树。\n\n具体来讲：\n\n1. 从根节点开始，对节点计算所有可能的特征的信息增益；\n\n2. 选择增益最大的特征作为节点的特征，以该特征的不同取值进行划分，建立子节点；\n\n3. 递归下去，直到信息增益很小（人为地设置一个阈值）或者无特征为止。\n\n缺点：ID3会对 包含类别较多 的特征有选择的偏向性，因此提出c4.5算法。\n\n#### C4.5算法\n\n与ID3的区别：\n\n1. 在特征选择时，先从候选属性中选择信息增益高于平均水平的属性，再从中选择信息增益率最高的属性；\n\n2. 此处的阈值是信息增益比的最小值。\n\n\n\n### 剪枝策略\n\n#### 为何剪枝：\n\n决策树生成算法根据训练集递归的生成了决策树，但是这样产生的树往往对训练数据集的分类很准确，却对测试数据集却没那么准确，即发生了过拟合现象。因此我们需要把复杂的树简单化。\n\n#### 预剪枝\n\n在选定了划分属性后，我们提出问题：是否应该进行这个划分？这就是预剪枝。\n\n预剪枝就是在完全正确分类训练集之前，较早地停止树的生长。\n\n具体在什么时候停止决策树的生长有多种不同的方法:\n\n1. 最为简单的方法：在决策树到达一定高度的情况下就停止树的生长；\n2. 定义一个阈值，当达到某个节点的实例个数小于阈值时就可以停止决策树的生长;\n3. 一种更为普遍的做法是计算划分前后系统精度的变化。如果更加精确，则允许划分，否则不允许（西瓜书4.31.节即采用本策略）。\n\n优点降低了过拟合，减少训练时间，***缺点容易带来欠拟合***。\n\n#### 后剪枝\n\n后剪枝技术要比预剪枝技术用得更加广泛。此处着重介绍。\n\n**方法1 - Reduced Error Pruning（西瓜书）**\n\n对于决策树T的每棵非叶子树S , 以“深度优先”的顺序，尝试用叶子替代这棵子树. 如果 S 被叶子替代后形成的新树关于数据集D的分类准确率等于或大于原树关于相同数据集D的准确率, 则用叶子替代子树S。\n\n**方法2 - 极小化决策树整体的损失函数（统计学习方法）**\n\n损失函数：\n\n$$C_α(T) = C(T)+α|T|=\\sum_{t=1}^{|T|}N_tH_t(T)+α|T|$$\n\n$$H_t(T)=−\\sum_{k}\\frac{N_{tk}}{N_t}log\\frac{N_{tk}}{N_t}$$ \n\n其中，$|T|$是树$T$的叶节点个数，$t$是其中一个结点，$N_t$是这个结点的样本个数，$H_t(T)$是这个结点的经验熵（就是普通的熵）。$C(T)$表示模型对训练数据的预测误差，即模型与训练数据的拟合程度， $|T|$是模型的复杂程度，$\\alpha$用来控制两者之间的关系。使用叶子结点的熵作为的模型的评价是因为：如果分到该叶节点的所有样本都属于同一类，不确定数量 = 不确定度 * 样本数量，那么分类效果最好，熵最小。\n\n在这里我存在疑问：\n\n叶结点上为什么存在k类样本点？即在该叶结点上，所有类别标签应该都是一致的。\n\n可能解释：\n\n1. 在该叶结点上没有足够的特征信息再把不一致的标签分开；\n2. 存在噪声点，何谓噪声，在类群中有极少个与类群不符的标签。\n\n\n\n###  <span id=\"cartdt\">CART决策树</span>\n\nCART决策树全称为classification and regression tree，CART假设决策树是二叉树，内部结点特征的取值为是和否，等价于递归地二分每个特征。\n\n#### CART 回归树\n\n见[CART回归树原理及示例](https://blog.csdn.net/aaa_aaa1sdf/article/details/81588382)。\n\n#### CART分类树\n\n分类树用Gini index选择最优的特征，同时决定该特征下的最优二分点。\n\n#### Concept_5 Gini index\n\n假设有K个类，样本点属于第k类的概率为$p_k$，则概率分布的Gini index定义为：\n\n$$Gini(p) = \\sum_{k=1}^{K}p_k(1-p_k)=1-\\sum_{k=1}^{K}p_k^2$$\n\n对于二分类问题，假设样本点是第一类的概率为$p$，则概率分布的Gini index为：\n\n$$Gini(p) = 2p(1-p)$$\n\n对于给定的样本集合D，把概率写作数量的比值，其Gini index为：\n\n$$Gini(D) = 1-\\sum_{k=1}^{K}(\\frac{|C_k|}{|D|})^2$$\n\n如果样本集合D根据特征A是否取某一可能的值a被分割成了$D_1$和$D_2$两个部分，则在特征A的条件下，集合D的基尼指数定义为：\n\n$$Gini(D, A)=\\frac{|D_1|}{|D|}Gini(D_1) + \\frac{|D_2|}{|D|}Gini(D_2)$$\n\n$Gini(D)$代表集合$D$的不确定性，$Gini(D, A)$表示经$A=a$分割后集合$D$的不确定性。Gini index越大，样本的不确定性就越大。\n\n#### CART分类树的生成\n\n伪代码总结为：\n\n```python\nfor  A in feature space:\n\tfor a in A.values:\n\t\tcalculateGini(A = a)\nchoose the lowest Gini index\n```\n\n《统计学习方法》相关描述为：\n\n<img src=\"【机器学习基础】决策树/image-20200318104650131.png\" alt=\"image-20200318104650131\" style=\"zoom: 50%;\" />\n\n<img src=\"【机器学习基础】决策树/image-20200318105140830.png\" alt=\"image-20200318105013644\" style=\"zoom:50%;\" />\n\n#### CART剪枝\n\n基本思路：CART剪枝算法从“完全生长”的决策树的底端剪去一些子树，使决策树变小（模型变简单），从而能够对未知数据有更准确的预测。CART剪枝算法由两步组成：1. 首先从生成算法产生的决策树$T_0$底端开始不断剪枝，直到$T_0$的根结点，形成一个子树序列{$T_0$,$T_1$,...,$T_n$}；2. 然后通过交叉验证法在独立的验证数据集上对子树序列进行测试，从中选择最优子树。\n\n接下来截取统计学习方法的内容。\n\n<img src=\"【机器学习基础】决策树/image-20200318111527018.png\" alt=\"image-20200318111527018\" style=\"zoom:50%;\" />\n\n<img src=\"【机器学习基础】决策树/image-20200318111742773.png\" alt=\"image-20200318111742773\" style=\"zoom:50%;\" />\n\n<img src=\"【机器学习基础】决策树/image-20200318113410309.png\" alt=\"image-20200318113410309\" style=\"zoom:50%;\" />\n\n#### CART剪枝的原理思考\n\nloss function的定义为：\n\n$$C_α(T) = C(T)+α|T|=\\sum_{t=1}^{|T|}N_tH_t(T)+α|T|$$\n\n对其进行变形：\n\n$$C_α(T) =\\sum_{t=1}^{|T|}(N_tH_t(T)+α)$$\n\n由此看出，衡量损失函数大小的真正贡献在于每一棵子树的叶结点，叶结点不确定次数的累加并加个常数$\\alpha $就是决策树整体的损失函数。\n\n","categories":["机器学习基础"]},{"title":"【NLP】对话生成任务中的数据清理","url":"/2020/02/17/【NLP】对话生成任务中的数据清理/","content":"\n在本次对话生成的任务中，需要对微博数据进行清理，去除其中不应feed到网络中的字符。主要包括以下：\n\n\n\n1. 颜文字；\n2. emoji；\n3. 相同且重复多次的正常标点只保留一个；\n4. 不同且重复多次的异常标点删掉；\n5. 话题标识删掉；\n6. @/via/http:后缀/cite删掉；\n\n\n\n下面是代码部分。在处理时因为赶时间，直接采用了暴力破解，只是在执行的先后顺序上做了一些调整，这里***MARK***，以后有时间做一下改进。\n\n```python\nimport jieba\nimport re\n\nduels = [x + y for x in list('。，!？！？:.（）()【】,《》\\'\\\"、,') \n                for y in list('。，!？！？:.（）()【】,《》\\'\\\"、,')]\ndef handle_symbol(text, duels):\n    '''\n        1. 删除重复的标点符号，只保留一个；\n        2. 删除特殊符号；\n    '''\n    remove = list('ノ¯︶ーσ･з∠~〜*&%$-_+=＊ｰ ̀ ́；●ヾД≤≥ε┏゜ロ┛□▔﹏∇ψ❤三 ڡ ♂ㄒ;∂‸Ծˋ๑ºั`·ﾟ\\\n                ゝ[]○▽￥←┴・｀.「﹃『』」∩ヽ ﾟ∀ｏ`´╭╮【Σっ★╥¬☆＜⌒ﾉ】→↑°╰╯┴x•ㅂ…|\\/^<\\\n                >口︵—≧≦⊙ω∑√')\n    for r in remove:\n        while r in text:\n            text = text.replace(r,\"\")\n    for d in duels:\n        while d in text:\n            if d[0] == d[1]: text = text.replace(d,d[0])\n            else: text = text.replace(d,\"\")\n    while text[0] in list('。，!？！？:.（）()【】,《》\\'\\\"、,'):\n        text = text[1:]\n    return text\ndef rm_ref(text):\n    '''\n        删除@/via/\n    '''\n    text = text.split(\"分享自via:\")[0] if \"分享自via:\" in text else text\n    text = text.split(\"（图via\")[0] if \"（图via\" in text else text\n    text = text.split(\"图via\")[0] if \"图via\" in text else text\n    text = text.split(\"@\")[0] if \"@\" in text else text\n    text = text.split(\"(via\")[0] if \"(via\" in text else text\n    text = text.split(\"\")[0] if \"via\" in text else text\n    text = text.split(\"by:\")[0] if \"via\" in text else text\n    text = text.split(\"(by\")[0] if \"via\" in text else text\n    return text\n\ndef filter_emoji(desstr,restr=''):  \n    '''\n        过滤emoji\n    '''   \n    try:  \n        res= re.compile(u'[\\U00010000-\\U0010ffff]')  \n    except re.error:  \n        res = re.compile(u'[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]')  \n    return res.sub(restr, desstr)\n\ndef rm_cite(text):\n    '''\n        删除http:/##/\n    '''\n    text = text.replace(\"http:\", \"\")\n    text = re.sub(r'#.*#', '', text)\n    return text\n\ntarget = open(\"after_cleaned_test.txt\", \"w\")\nwith open(\"./tweets_cleaned.txt\", 'r') as f:\n    for line in f:\n        try:\n            line = line.strip().split(\"\\t\")\n            # 清洗\n            line[3] = rm_ref(line[3])\n            line[3] = filter_emoji(line[3])\n            line[3] = rm_cite(line[3])\n            line[3] = handle_symbol(line[3], duels)\n            line[7] = rm_ref(line[7])\n            line[7] = filter_emoji(line[7])\n            line[7] = rm_cite(line[7])\n            line[7] = handle_symbol(line[7], duels)\n            \n            # 分词\n            line[3] = \" \".join(jieba.cut(line[3], cut_all=False))\n            line[7] = \" \".join(jieba.cut(line[7], cut_all=False))\n            target.write(\"\\t\".join(line) + \"\\n\")\n        except:\n            continue\n\n```","tags":["EMNLP2020"],"categories":["NLP"]},{"title":"【NLP】统计学习的语言模型","url":"/2020/02/15/【NLP】统计学习的语言模型/","content":"\n\n\n# 语言模型\n\n一段自然语言文本可以看作是一个离散时间序列，给定一个长度为$T$的词的序列$w_1, w_2, \\ldots, w_T$。\n语言模型的目标就是评估该序列是否合理，即计算该序列的概率：\n\n$$\nP(w_1, w_2, \\ldots, w_T) \n$$\n\n\n本节我们介绍基于统计的语言模型，主要是$n$元语法（$n$-gram）。在后续内容中，我们将会介绍基于神经网络的语言模型。\n\n\n\n## 统计学习的语言模型\n\n\n假设序列$w_1, w_2, \\ldots, w_T$中的每个词是依次生成的，我们有\n\n\n$$\n\\begin{align*}\nP(w_1, w_2, \\ldots, w_T)\n&= \\prod_{t=1}^T P(w_t \\mid w_1, \\ldots, w_{t-1})\\\\\n&= P(w_1)P(w_2 \\mid w_1) \\cdots P(w_T \\mid w_1w_2\\cdots w_{T-1})\n\\end{align*}\n$$\n\n\n例如，一段含有4个词的文本序列的概率\n\n\n$$\nP(w_1, w_2, w_3, w_4) =  P(w_1) P(w_2 \\mid w_1) P(w_3 \\mid w_1, w_2) P(w_4 \\mid w_1, w_2, w_3).\n$$\n\n\n语言模型的参数就是词的概率以及给定前几个词情况下的条件概率。设训练数据集为一个大型文本语料库，如维基百科的所有条目，词的概率可以通过该词在训练数据集中的相对词频来计算，例如，$w_1$的概率可以计算为：\n\n\n$$\n\\hat P(w_1) = \\frac{n(w_1)}{n}\n$$\n\n\n其中$n(w_1)$为语料库中以$w_1$作为第一个词的文本的数量，$n$为语料库中文本的总数量。\n\n类似的，给定$w_1$情况下，$w_2$的条件概率可以计算为：\n\n\n$$\n\\hat P(w_2 \\mid w_1) = \\frac{n(w_1, w_2)}{n(w_1)}\n$$\n\n其中$n(w_1, w_2)$为语料库中以$w_1$作为第一个词，$w_2$作为第二个词的文本的数量。\n\n***注意，这里的n指的不是w1,w1w2单词出现的次数，而是以w1, w1w2开头的文本数量。***\n\n\n\n## n元语法\n\n序列长度增加，计算和存储多个词共同出现的概率的复杂度会呈指数级增加。$n$元语法通过马尔可夫假设简化模型，马尔科夫假设是指一个词的出现只与前面$n$个词相关，即$n$阶马尔可夫链（Markov chain of order $n$），如果$n=1$，那么有$P(w_3 \\mid w_1, w_2) = P(w_3 \\mid w_2)$。基于$n-1$阶马尔可夫链，我们可以将语言模型改写为\n\n\n$$\nP(w_1, w_2, \\ldots, w_T) = \\prod_{t=1}^T P(w_t \\mid w_{t-(n-1)}, \\ldots, w_{t-1}) .\n$$\n\n\n以上也叫$n$元语法（$n$-grams），它是基于$n - 1$阶马尔可夫链的概率语言模型。例如，当$n=2$时，含有4个词的文本序列的概率就可以改写为：\n\n\n$$\n\\begin{align*}\nP(w_1, w_2, w_3, w_4)\n&= P(w_1) P(w_2 \\mid w_1) P(w_3 \\mid w_1, w_2) P(w_4 \\mid w_1, w_2, w_3)\\\\\n&= P(w_1) P(w_2 \\mid w_1) P(w_3 \\mid w_2) P(w_4 \\mid w_3)\n\\end{align*}\n$$\n\n\n当$n$分别为1、2和3时，我们将其分别称作一元语法（unigram）、二元语法（bigram）和三元语法（trigram）。例如，长度为4的序列$w_1, w_2, w_3, w_4$在一元语法、二元语法和三元语法中的概率分别为\n\n\n$$\n\\begin{aligned}\nP(w_1, w_2, w_3, w_4) &=  P(w_1) P(w_2) P(w_3) P(w_4) ,\\\\\nP(w_1, w_2, w_3, w_4) &=  P(w_1) P(w_2 \\mid w_1) P(w_3 \\mid w_2) P(w_4 \\mid w_3) ,\\\\\nP(w_1, w_2, w_3, w_4) &=  P(w_1) P(w_2 \\mid w_1) P(w_3 \\mid w_1, w_2) P(w_4 \\mid w_2, w_3) .\n\\end{aligned}\n$$\n\n当$n$较小时，$n$元语法往往并不准确。例如，在一元语法中，由三个词组成的句子“你走先”和“你先走”的概率是一样的。然而，当$n$较大时，$n$元语法需要计算并存储大量的词频和多词相邻频率。\n\n\n\n***思考：$n$元语法可能有哪些缺陷?***\n\n1. 参数空间过大；\n2. 数据稀疏。\n\n\n\n## 语言模型数据集\n### 读取数据集\n\n```python\nwith open('jaychou_lyrics.txt') as f:\n    corpus_chars = f.read()\nprint(len(corpus_chars))\nprint(corpus_chars[: 40])\ncorpus_chars = corpus_chars.replace('\\n', ' ').replace('\\r', ' ')\ncorpus_chars = corpus_chars[: 10000] # 只保留前10000个字符\n\n# output\n# 63282\n# 想要有直升机\n# 想要和你飞到宇宙去\n# 想要和你融化在一起\n# 融化在宇宙里\n# 我每天每天每\n```\n\n### 建立字符索引\n\n```python\nidx_to_char = list(set(corpus_chars)) # 去重，得到索引到字符的映射\nchar_to_idx = {char: i for i, char in enumerate(idx_to_char)} # 字典推导式，构造字符到索引的映射\nvocab_size = len(char_to_idx)\nprint(vocab_size)\n\ncorpus_indices = [char_to_idx[char] for char in corpus_chars]  # 将每个字符转化为索引，得到一个索引的序列\nsample = corpus_indices[: 20]\nprint('chars:', ''.join([idx_to_char[idx] for idx in sample]))\nprint('indices:', sample)\n\n# output:\n# 1027\n# chars: 想要有直升机 想要和你飞到宇宙去 想要和\n# indices: [519, 525, 36, 664, 964, 16, 522, 519, 525, 184, 784, 828, 218, 371, 618, 889, 522, 519, 525, 184]\n\n# 定义函数`load_data_jay_lyrics`，在后续章节中直接调用。\ndef load_data_jay_lyrics():\n    with open('jaychou_lyrics.txt') as f:\n        corpus_chars = f.read()\n    corpus_chars = corpus_chars.replace('\\n', ' ').replace('\\r', ' ')\n    corpus_chars = corpus_chars[0:10000]\n    idx_to_char = list(set(corpus_chars))\n    char_to_idx = dict([(char, i) for i, char in enumerate(idx_to_char)])\n    vocab_size = len(char_to_idx)\n    corpus_indices = [char_to_idx[char] for char in corpus_chars]\n    return corpus_indices, char_to_idx, idx_to_char, vocab_size\n```\n\n\n\n## 时序数据的采样\n\n在训练中我们需要每次随机读取小批量样本和标签。与之前章节的实验数据不同的是，时序数据的一个样本通常包含连续的字符。假设时间步数为5，样本序列为5个字符，即“想”“要”“有”“直”“升”。该样本的标签序列为这些字符分别在训练集中的下一个字符，即“要”“有”“直”“升”“机”，即$X$=“想要有直升”，$Y$=“要有直升机”。\n\n现在我们考虑序列“想要有直升机，想要和你飞到宇宙去”，如果时间步数为5，有以下可能的样本和标签：\n\n- $X$：“想要有直升”，$Y$：“要有直升机”\n- $X$：“要有直升机”，$Y$：“有直升机，”\n- $X$：“有直升机，”，$Y$：“直升机，想”\n- ...\n- $X$：“要和你飞到”，$Y$：“和你飞到宇”\n- $X$：“和你飞到宇”，$Y$：“你飞到宇宙”\n- $X$：“你飞到宇宙”，$Y$：“飞到宇宙去”\n\n可以看到，如果序列的长度为$T$，时间步数为$n$，那么一共有$T-n$个合法的样本，**但是这些样本有大量的重合**，我们通常采用更加高效的采样方式。我们有两种方式对时序数据进行采样，分别是随机采样和相邻采样。\n\n### 随机采样\n\n下面的代码每次从数据里随机采样一个小批量。其中批量大小`batch_size`是每个小批量的样本数，`num_steps`是每个样本所包含的时间步数。\n在随机采样中，每个样本是原始序列上任意截取的一段序列，相邻的两个随机小批量在原始序列上的位置不一定相毗邻。\n\n![1](统计学习的语言模型/1.png)\n\n```python\nimport torch\nimport random\ndef data_iter_random(corpus_indices, batch_size, num_steps, device=None):\n    # 减1是因为对于长度为n的序列，X最多只有包含其中的前n - 1个字符\n    num_examples = (len(corpus_indices) - 1) // num_steps  # 下取整，得到不重叠情况下的样本个数\n    example_indices = [i * num_steps for i in range(num_examples)]  # 每个样本的第一个字符在corpus_indices中的下标\n    random.shuffle(example_indices)\n\n    def _data(i):\n        # 返回从i开始的长为num_steps的序列\n        return corpus_indices[i: i + num_steps]\n    if device is None:\n        device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n    \n    for i in range(0, num_examples, batch_size):\n        # 每次选出batch_size个随机样本\n        batch_indices = example_indices[i: i + batch_size]  # 当前batch的各个样本的首字符的下标\n        X = [_data(j) for j in batch_indices]\n        Y = [_data(j + 1) for j in batch_indices]\n        yield torch.tensor(X, device=device), torch.tensor(Y, device=device)\n```\n\n测试一下这个函数，我们输入从0到29的连续整数作为一个人工序列，设批量大小和时间步数分别为2和6，打印随机采样每次读取的小批量样本的输入`X`和标签`Y`。\n\n```python\nmy_seq = list(range(30))\nfor X, Y in data_iter_random(my_seq, batch_size=2, num_steps=5):\n    print('X: ', X, '\\nY:', Y, '\\n')\n   \n# output:\n# X: tensor([[20, 21, 22, 23, 24],\n#         [ 5,  6,  7,  8,  9]]) \n# Y: tensor([[21, 22, 23, 24, 25],\n#         [ 6,  7,  8,  9, 10]]) \n#\n# X:  tensor([[ 0,  1,  2,  3,  4],\n#         [10, 11, 12, 13, 14]]) \n# Y: tensor([[ 1,  2,  3,  4,  5],\n#         [11, 12, 13, 14, 15]]) \n#\n# X:  tensor([[15, 16, 17, 18, 19]]) \n# Y: tensor([[16, 17, 18, 19, 20]]) \n```\n\n\n\n### 相邻采样\n\n除对原始序列做随机采样之外，我们还可以令相邻的两个随机小批量在原始序列上的位置相毗邻。这时候，我们就可以用前一个小批量最终时间步的隐藏状态来初始化下一个小批量的隐藏状态，从而使下一个小批量的输出也取决于当前小批量的输入，并如此循环下去。这对实现循环神经网络造成了两方面影响：\n\n一方面，在训练模型时，我们只需在每一个迭代周期开始时初始化隐藏状态；\n\n另一方面，当多个相邻小批量通过传递隐藏状态串联起来时，模型参数的梯度计算将依赖所有串联起来的小批量序列。同一迭代周期中，随着迭代次数的增加，梯度的计算开销会越来越大。\n\n为了使模型参数的梯度计算只依赖一次迭代读取的小批量序列，我们可以在每次读取小批量前将隐藏状态从计算图中分离出来。我们将在下一节（循环神经网络的从零开始实现）的实现中了解这种处理方式。\n\n![2](统计学习的语言模型/2.png)\n\n```python\ndef data_iter_consecutive(corpus_indices, batch_size, num_steps, device=None):\n    if device is None:\n        device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n    corpus_len = len(corpus_indices) // batch_size * batch_size  # 保留下来的序列的长度\n    corpus_indices = corpus_indices[: corpus_len]  # 仅保留前corpus_len个字符，以保证可以整除batch_size\n    indices = torch.tensor(corpus_indices, device=device)\n    indices = indices.view(batch_size, -1)  # resize成(batch_size, )\n    batch_num = (indices.shape[1] - 1) // num_steps\n    for i in range(batch_num):\n        i = i * num_steps\n        X = indices[:, i: i + num_steps]\n        Y = indices[:, i + 1: i + num_steps + 1]\n        yield X, Y\n        \nfor X, Y in data_iter_consecutive(my_seq, batch_size=2, num_steps=6):\n    print('X: ', X, '\\nY:', Y, '\\n')\n    \n# output:\n# X:  tensor([[ 0,  1,  2,  3,  4,  5],\n#         [15, 16, 17, 18, 19, 20]]) \n# Y: tensor([[ 1,  2,  3,  4,  5,  6],\n#         [16, 17, 18, 19, 20, 21]]) \n#\n# X:  tensor([[ 6,  7,  8,  9, 10, 11],\n#         [21, 22, 23, 24, 25, 26]]) \n# Y: tensor([[ 7,  8,  9, 10, 11, 12],\n#         [22, 23, 24, 25, 26, 27]]) \n```\n\n","tags":["Dive系列"],"categories":["NLP"]},{"title":"【NLP】文本预处理","url":"/2020/02/15/【NLP】文本预处理/","content":"\n\n\n## 文本预处理\n\n文本是一类序列数据，一篇文章可以看作是字符或单词的序列，本节将介绍文本数据的常见预处理步骤，预处理通常包括四个步骤：1. 读入文本；2. 句子转化为词序列；3. 建立字典，将每个词映射到一个唯一的索引；4.将文本从词的序列转换为索引的序列，方便输入模型。\n\n\n\n### 读入文本\n\n我们用一部英文小说，即H. G. Well的[Time Machine](http://www.gutenberg.org/ebooks/35)，作为示例，展示文本预处理的具体过程。\n\n``` python\nimport collections\nimport re\n\ndef read_time_machine():\n    with open('timemachine.txt', 'r') as f:\n        # 此处正则表达式表示：1.去掉开头结尾的空格和制表符；2.大写字母转小写；\n        # 3.把所有的非a-z的字符转化为空格。\n        lines = [re.sub('[^a-z]+', ' ', line.strip().lower()) for line in f]\n    return lines\n    \nlines = read_time_machine()\nprint('Info: Num of sentences is %d.' % len(lines))\n\n# output: Info: Num of sentences is 3221.\n```\n\n\n\n### 句子转化为词序列 - 简单的分词\n\n将一个句子划分成若干个词（token），转换为一个词的序列。\n``` python\ndef tokenize(sentences, token):\n    \"\"\"Split sentences into word or char tokens\"\"\"\n    if token == 'word':\n        return [sentence.split(' ') for sentence in sentences]\n    elif token == 'char':\n        return [list(sentence) for sentence in sentences]\n    else:\n        print('ERROR: unkown token type '+token)\n        \ntokens = tokenize(lines, 'word')\ntokens[0:2]\n\n# output: [['the', 'time', 'machine', 'by', 'h', 'g', 'wells', ''], ['']]\n```\n\n\n\n### 建立字典\n\n为了方便模型处理，我们需要将字符串转换为数字。因此我们需要先构建一个字典（vocabulary），将每个词映射到一个唯一的索引编号。\n\n```python\nclass Vocab(object):\n    def __init__(self, tokens, min_freq=0, use_special_tokens=False):\n        # min_freq为阈值\n        counter = count_corpus(tokens)\n        self.token_freqs = list(counter.items())\n        self.idx_to_token = []\n        if use_special_tokens:\n            # padding, begin of sentence, end of sentence, unknown\n            # unk是指在语料库中未出现过的token\n            # 需要注意：无论use_special_token参数是否为真，都会使用UNK来表示未登录词。\n            self.pad, self.bos, self.eos, self.unk = (0, 1, 2, 3)\n            self.idx_to_token += ['', '', '', '']\n        else:\n            self.unk = 0\n            self.idx_to_token += ['']\n        self.idx_to_token += [token for token, freq in self.token_freqs\n                        if freq >= min_freq and token not in self.idx_to_token]\n        self.token_to_idx = dict()\n        for idx, token in enumerate(self.idx_to_token):\n            self.token_to_idx[token] = idx\n\n    def __len__(self):\n        return len(self.idx_to_token)\n\n    def __getitem__(self, tokens):\n        if not isinstance(tokens, (list, tuple)):\n            return self.token_to_idx.get(tokens, self.unk)\n        return [self.__getitem__(token) for token in tokens]\n\n    def to_tokens(self, indices):\n        if not isinstance(indices, (list, tuple)):\n            return self.idx_to_token[indices]\n        return [self.idx_to_token[index] for index in indices]\n\ndef count_corpus(sentences):\n    tokens = [tk for st in sentences for tk in st]\n    return collections.Counter(tokens)  # 返回一个字典，记录每个词的出现次数\n  \n  \nvocab = Vocab(tokens)\nprint(list(vocab.token_to_idx.items())[0:10])\n\n# output: [('', 0), ('the', 1), ('time', 2), ('machine', 3), ('by', 4), ('h', 5), ('g', 6), ('wells', 7), ('i', 8), ('traveller', 9)]\n```\n\n\n\n### 将词转为索引\n\n使用字典，我们可以将原文本中的句子从单词序列转换为索引序列。\n\n```python\nfor i in range(8, 10):\n    print('words:', tokens[i])\n    print('indices:', vocab[tokens[i]])\n    \n# output: \n# words: ['the', 'time', 'traveller', 'for', 'so', 'it', 'will', 'be', 'convenient', 'to', 'speak', 'of', 'him', '']\n# indices: [1, 2, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 0]\n# words: ['was', 'expounding', 'a', 'recondite', 'matter', 'to', 'us', 'his', 'grey', 'eyes', 'shone', 'and']\n# indices: [20, 21, 22, 23, 24, 16, 25, 26, 27, 28, 29, 30]\n```\n\n\n\n### 用现有工具进行分词\n\n我们前面介绍的分词方式非常简单，它至少有以下几个缺点:\n1. 标点符号通常可以提供语义信息，但是我们的方法直接将其丢弃了\n2. 类似“shouldn't\", \"doesn't\"这样的词会被错误地处理\n3. 类似\"Mr.\", \"Dr.\"这样的词会被错误地处理\n\n我们可以通过引入更复杂的规则来解决这些问题.\n\n下面是一个简单的例子：\n\n```python\ntext = \"Mr. Chen doesn't agree with my suggestion.\"\nfrom nltk.tokenize import word_tokenize\nprint(word_tokenize(text))\n\n# output: ['Mr.', 'Chen', 'does', \"n't\", 'agree', 'with', 'my', 'suggestion', '.']\n```\n\n","tags":["Dive系列"],"categories":["NLP"]},{"title":"【GNN】Note：图深度表示基础和前沿进展","url":"/2020/02/10/【GNN】Note：图深度表示基础和前沿进展/","content":"\n![1](【GNN】Note：图深度表示基础和前沿进展/1.jpg)\n\n![2](【GNN】Note：图深度表示基础和前沿进展/2.jpg)\n\n![3](【GNN】Note：图深度表示基础和前沿进展/3.jpg)\n\n![4](【GNN】Note：图深度表示基础和前沿进展/4.jpg)\n\n![5](【GNN】Note：图深度表示基础和前沿进展/5.jpg)\n\n![6](【GNN】Note：图深度表示基础和前沿进展/6.jpg)\n\n![7](【GNN】Note：图深度表示基础和前沿进展/7.jpg)\n\n![8](【GNN】Note：图深度表示基础和前沿进展/8.jpg)\n\n![9](【GNN】Note：图深度表示基础和前沿进展/9.jpg)","tags":["GNN"],"categories":["GNN"]},{"title":"【CS224N】L1. Word Embedding","url":"/2020/01/18/【CS224N】L1. Introduction and Word Vectors/","content":"\n![1](【NLP】L1-Introduction-and-Word-Vectors/1.jpg)\n\n![2](【NLP】L1-Introduction-and-Word-Vectors/2.jpg)\n\n![3](【NLP】L1-Introduction-and-Word-Vectors/3.jpg)","tags":["CS224N"],"categories":["NLP"]},{"title":"Hello World","url":"/2020/01/11/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]