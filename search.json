[{"title":"test","url":"/2020/01/11/test-1/"},{"title":"3.7 softmax回归的简洁实现","url":"/2020/01/11/3.7_softmax-regression-pytorch/","content":"\n\n\n# 3.7 softmax回归的简洁实现\n\n我们在3.3节（线性回归的简洁实现）中已经了解了使用Pytorch实现模型的便利。下面，让我们再次使用Pytorch来实现一个softmax回归模型。首先导入所需的包或模块。\n\n``` python\nimport torch\nfrom torch import nn\nfrom torch.nn import init\nimport numpy as np\nimport sys\nsys.path.append(\"..\") \nimport d2lzh_pytorch as d2l\n```\n\n## 3.7.1 获取和读取数据\n\n我们仍然使用Fashion-MNIST数据集和上一节中设置的批量大小。\n\n``` python\nbatch_size = 256\ntrain_iter, test_iter = d2l.load_data_fashion_mnist(batch_size)\n```\n\n## 3.7.2 定义和初始化模型\n\n在3.4节（softmax回归）中提到，softmax回归的输出层是一个全连接层，所以我们用一个线性模块就可以了。因为前面我们数据返回的每个batch样本`x`的形状为(batch_size, 1, 28, 28), 所以我们要先用`view()`将`x`的形状转换成(batch_size, 784)才送入全连接层。\n\n``` python\nnum_inputs = 784\nnum_outputs = 10\n\nclass LinearNet(nn.Module):\n    def __init__(self, num_inputs, num_outputs):\n        super(LinearNet, self).__init__()\n        self.linear = nn.Linear(num_inputs, num_outputs)\n    def forward(self, x): # x shape: (batch, 1, 28, 28)\n        y = self.linear(x.view(x.shape[0], -1))\n        return y\n    \nnet = LinearNet(num_inputs, num_outputs)\n```\n\n我们将对`x`的形状转换的这个功能自定义一个`FlattenLayer`并记录在`d2lzh_pytorch`中方便后面使用。\n``` python\n# 本函数已保存在d2lzh_pytorch包中方便以后使用\nclass FlattenLayer(nn.Module):\n    def __init__(self):\n        super(FlattenLayer, self).__init__()\n    def forward(self, x): # x shape: (batch, *, *, ...)\n        return x.view(x.shape[0], -1)\n```\n\n这样我们就可以更方便地定义我们的模型：\n``` python\nfrom collections import OrderedDict\nnet = nn.Sequential(\n        # FlattenLayer(),\n        # nn.Linear(num_inputs, num_outputs)\n        OrderedDict([\n          ('flatten', FlattenLayer()),\n          ('linear', nn.Linear(num_inputs, num_outputs))])\n        )\n```\n\n然后，我们使用均值为0、标准差为0.01的正态分布随机初始化模型的权重参数。\n\n``` python\ninit.normal_(net.linear.weight, mean=0, std=0.01)\ninit.constant_(net.linear.bias, val=0) \n```\n\n\n## 3.7.3 softmax和交叉熵损失函数\n\n如果做了上一节的练习，那么你可能意识到了分开定义softmax运算和交叉熵损失函数可能会造成数值不稳定。因此，PyTorch提供了一个包括softmax运算和交叉熵损失计算的函数。它的数值稳定性更好。\n\n``` python\nloss = nn.CrossEntropyLoss()\n```\n\n## 3.7.4 定义优化算法\n\n我们使用学习率为0.1的小批量随机梯度下降作为优化算法。\n\n``` python\noptimizer = torch.optim.SGD(net.parameters(), lr=0.1)\n```\n\n## 3.7.5 训练模型\n\n接下来，我们使用上一节中定义的训练函数来训练模型。\n\n``` python\nnum_epochs = 5\nd2l.train_ch3(net, train_iter, test_iter, loss, num_epochs, batch_size, None, None, optimizer)\n```\n输出：\n```\nepoch 1, loss 0.0031, train acc 0.745, test acc 0.790\nepoch 2, loss 0.0022, train acc 0.812, test acc 0.807\nepoch 3, loss 0.0021, train acc 0.825, test acc 0.806\nepoch 4, loss 0.0020, train acc 0.832, test acc 0.810\nepoch 5, loss 0.0019, train acc 0.838, test acc 0.823\n```\n\n## 小结\n\n* PyTorch提供的函数往往具有更好的数值稳定性。\n* 可以使用PyTorch更简洁地实现softmax回归。\n\n-----------\n> 注：本节除了代码之外与原书基本相同，[原书传送门](https://zh.d2l.ai/chapter_deep-learning-basics/softmax-regression-gluon.html)","tags":["PyTorch"]},{"title":"test","url":"/2020/01/11/test/"},{"title":"Hello World","url":"/2020/01/11/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]